<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ifunnyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-30T16:28:03.880Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Johnny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>runtime数据结构</title>
    <link href="http://yoursite.com/2019/01/31/ios/Runtime%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/01/31/ios/Runtime数据结构/</id>
    <published>2019-01-30T16:12:00.000Z</published>
    <updated>2019-01-30T16:28:03.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li>objc_object<ul><li>对象</li></ul></li><li>objc_class<ul><li>类，类对象</li></ul></li><li>isa指针<ul><li>共用体isa_t</li></ul></li><li>method_t<ul><li>方法定义</li></ul></li></ul><h2 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h2><p><img src="/2019/01/31/ios/Runtime数据结构/33070F0E-F45F-4BC1-AFD5-9E3176410E83.png" alt="33070F0E-F45F-4BC1-AFD5-9E3176410E83"></p><font color="green">平时我们使用的所有对象都是id类型的，对应runtime中objc_object结构体</font><ul><li>isa_t<ul><li>共用体</li></ul></li><li>关于isa操作相关<ul><li>比如通过objc_object这个结构体来获取它的isa所指向的类对象，包括通过类对象的isa指针获取它的元类对象</li></ul></li><li>弱引用相关<ul><li>比如标记一个对象是否曾经弱引用指针</li></ul></li><li>关联对象相关<ul><li>比如这个对象我们为它设置了一些关联属性和关联方法</li></ul></li><li>内存管理相关<ul><li>比如MRC下的retain和release，或者ARC和MRC下都可以用到的autoreleasepool</li></ul></li></ul><h2 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h2><p><img src="/2019/01/31/ios/Runtime数据结构/858A8E75-50E2-461F-B5CD-43460D412F88.png" alt="858A8E75-50E2-461F-B5CD-43460D412F88"></p><font color="green">OC中所使用的Class实际上对应的是runtime中objc_class这个结构体</font><font color="red">objc_class继承自objc_object，所以Class是个对象，类对象</font><ul><li><font color="red">Class</font> superClass<ul><li>指向父类对象</li></ul></li><li><p><font color="red">cache_t</font> cache</p><ul><li>方法缓存结构</li></ul></li><li><p><font color="red">class_data_bits_t</font> bits</p><ul><li>实际关于一个类定义所定义的变量、属性，包括方法都在bits里面</li></ul></li></ul><blockquote><p>（面试题）Class是否是对象</p><p>​    是，类对象，因为它继承自objc_object。</p></blockquote><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><p>共用体isa_t</p><p><img src="/2019/01/31/ios/Runtime数据结构/507F59A9-A72C-4961-B9D6-2E7506D96C66.png" alt="507F59A9-A72C-4961-B9D6-2E7506D96C66"></p><font color="green">isa_t在32位或者64位架构上面，实际下都是一串32位或者64位0或者1数字</font><ul><li>指针型isa<ul><li>isa的值代表Class的地址</li></ul></li><li>非指针型isa<ul><li>isa的值的部分代表Class的地址</li><li>剩下的部分可以存储一些其他内容来达到节省内存的目的</li></ul></li></ul><h2 id="isa指向"><a href="#isa指向" class="headerlink" title="isa指向"></a>isa指向</h2><ul><li>关于<font color="red">对象</font>，其指向<font color="red">类对象</font>。<ul><li>实例   —isa—&gt;   Class</li><li>我们通过一个<font color="red">实例</font>去调用<font color="red">实例方法</font>，就是通过<font color="red">对象的isa指针</font>到它的<font color="red">类对象</font>进行方法查找</li></ul></li><li>关于<font color="red">类对象</font>，其指向<font color="red">元类对象（MeteClass）</font>。<ul><li>Class   —isa—&gt;   MetaClass</li><li>我们通过一个<font color="red">类</font>去调用<font color="red">类方法</font>，就是通过<font color="red">类对象的isa指针</font>到它的<font color="red">元类</font>去进行方法查找</li></ul></li></ul><h2 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h2><ul><li>用于<font color="red">快速</font>查找方法执行函数<ul><li>比如我们调用一个方法的时候，如果之前调用并缓存起来，就不用到方法列表进行遍历查找</li></ul></li><li>是可<font color="red">增量扩展</font>的<font color="red">哈希表</font>结构<ul><li>会根据存储增量去扩大内存空间</li><li>用哈希表是为了增加查找效率</li></ul></li><li>是<font color="red">局部性原理</font>的最佳应用<ul><li>把平时调用频次最高的方法放在缓存中</li><li>时间局部性是指被引用过的存储器位置很可能会被再次引用</li><li>空间局部性是指被引用过的存储器位置附近的数据很可能将被引用</li></ul></li></ul><p><img src="/2019/01/31/ios/Runtime数据结构/62E55D07-5139-4E95-BFEE-3673E274409E.png" alt="62E55D07-5139-4E95-BFEE-3673E274409E"></p><h2 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h2><ul><li><font color="red">class_data_bits_t</font>主要是对<font color="red">class_rw_t</font>的封装<ul><li>class_rw_t<font color="red">可读可写</font>，就说明我们可以随时创建分类来给这个类添加属性和方法</li></ul></li><li><font color="red">class_rw_t</font>代表了类相关的<font color="red">读写</font>信息，对<font color="red">class_ro_t</font>的封装<ul><li>class_ro_t<font color="red">只读</font>，当我们创建一个类的时候为它添加的成员变量和方法列表，在之后就没办法修改了</li></ul></li><li><font color="red">class_ro_t</font>代表了类相关的<font color="red">只读</font>信息</li></ul><h2 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h2><p><img src="/2019/01/31/ios/Runtime数据结构/D7BDBFEA-4BDF-4730-BB82-C954073E1433.png" alt="D7BDBFEA-4BDF-4730-BB82-C954073E1433"></p><font color="green">我们在为一个类添加分类的协议、属性和方法就是对应上图的protocols、properties和methods</font><p>protocols、properties和methods这三个结构都<font color="red">继承</font>于list_array_tt这个<font color="red">二维数组</font></p><h2 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h2><p><img src="/2019/01/31/ios/Runtime数据结构/7B5FAA7A-0985-4E79-AD36-32E0C5D5A81B.png" alt="7B5FAA7A-0985-4E79-AD36-32E0C5D5A81B"></p><ul><li>name：类名。<ul><li>平时我们用的NSClassFromString(@”ClassName”)，通过String获取一个类</li></ul></li><li>ivars：类的成员变量</li><li>properties：类的属性<ul><li><font color="red">原始定义的属性</font></li></ul></li><li>protocols：类遵从的协议<ul><li><font color="red">原始遵从的协议</font></li></ul></li><li>methodList：类添加的方法列表<ul><li><font color="red">原始定义的方法</font></li><li>class_ro_t的方法列表和class_rw_t的方法列表是有区别的，前者是一维数组，后者是二维数组</li></ul></li></ul><h2 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h2><p><img src="/2019/01/31/ios/Runtime数据结构/6D6C466F-8252-40EC-AE60-199083A66373.png" alt="6D6C466F-8252-40EC-AE60-199083A66373"></p><ul><li>IMP：无类型的函数指针，函数体。<ul><li>IMP指针是指向实现函数的指针, 通过SEL取得IMP, objc_msgSend来执行实现方法。</li></ul></li></ul><h2 id="Type-Encodings"><a href="#Type-Encodings" class="headerlink" title="Type Encodings"></a>Type Encodings</h2><p><img src="/2019/01/31/ios/Runtime数据结构/F7127E65-A1D1-4D2C-8DD4-ABB48969BE5C.png" alt="F7127E65-A1D1-4D2C-8DD4-ABB48969BE5C"></p><ul><li>const char *types;<ul><li>不可变的字符指针</li><li>第一位永远都是函数的返回值</li></ul></li></ul><font color="green">调用一个方法，在runtime层面上都会转成objc_msgsend这样的函数调用，函数调用的第一个参数和第二个参数是固定的，并且是不可变的，第一个参数必须是id类型的，为消息的接收者，比如self这个对象，第二个是选择器SEL。</font><h1 id="整体数据结构"><a href="#整体数据结构" class="headerlink" title="整体数据结构"></a>整体数据结构</h1><p><img src="/2019/01/31/ios/Runtime数据结构/64D2B528-5AD9-42C3-B109-FB012EC19DB6.png" alt="64D2B528-5AD9-42C3-B109-FB012EC19DB6"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;objc_object&lt;ul&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;objc_class&lt;u
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>ipa 重新签名</title>
    <link href="http://yoursite.com/2018/08/16/ios/ipa%E9%87%8D%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/08/16/ios/ipa重签/</id>
    <published>2018-08-16T08:56:00.000Z</published>
    <updated>2018-08-16T08:57:04.998Z</updated>
    
    <content type="html"><![CDATA[<p>批量替换脚本：<a href="https://github.com/ifunnyy/ipa-batch-signature-again" target="_blank" rel="noopener">https://github.com/ifunnyy/ipa-batch-signature-again</a></p><p>ipa 重签的操作主要分为以下几步：</p><ol><li>先将ipa包进行解压</li><li>删除Payload/xxx.app/_CodeSignature里面的文件</li><li>替换embedded.mobileprovision</li><li>生成entitlements.plist</li><li>进行重新签名</li><li>重新打包</li></ol><p>假设证书和ipa包都在同个目录下</p><h1 id="先将ipa包进行解压"><a href="#先将ipa包进行解压" class="headerlink" title="先将ipa包进行解压"></a>先将ipa包进行解压</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip xxx.ipa</span><br></pre></td></tr></table></figure><h1 id="删除Payload-xxx-app-CodeSignature里面的文件"><a href="#删除Payload-xxx-app-CodeSignature里面的文件" class="headerlink" title="删除Payload/xxx.app/_CodeSignature里面的文件"></a>删除Payload/xxx.app/_CodeSignature里面的文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -fr Payload/xxx.app/_CodeSignature/</span><br></pre></td></tr></table></figure><h1 id="替换embedded-mobileprovision"><a href="#替换embedded-mobileprovision" class="headerlink" title="替换embedded.mobileprovision"></a>替换embedded.mobileprovision</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp embedded.mobileprovision Payload/xxx.app/embedded.mobileprovision</span><br></pre></td></tr></table></figure><h1 id="生成entitlements-plist"><a href="#生成entitlements-plist" class="headerlink" title="生成entitlements.plist"></a>生成entitlements.plist</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security cms -D -i embedded.mobileprovision &gt; entitlements_full.plist</span><br><span class="line"></span><br><span class="line">/usr/libexec/PlistBuddy -x -c &apos;Print:Entitlements&apos; entitlements_full.plist &gt; entitlements.plist</span><br></pre></td></tr></table></figure><h1 id="进行重新签名"><a href="#进行重新签名" class="headerlink" title="进行重新签名"></a>进行重新签名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/codesign -f -s &quot;证书名称&quot; --entitlements entitlements.plist Payload/xxx.app/</span><br></pre></td></tr></table></figure><h1 id="重新打包"><a href="#重新打包" class="headerlink" title="重新打包"></a>重新打包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r xxx.ipa Payload/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;批量替换脚本：&lt;a href=&quot;https://github.com/ifunnyy/ipa-batch-signature-again&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ifunnyy/ipa-batch
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>题目</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/题目/</id>
    <published>2018-08-14T09:16:00.000Z</published>
    <updated>2018-08-15T06:56:26.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、JavaScript的call和apply方法是做什么的，两者有什么区别？"><a href="#1、JavaScript的call和apply方法是做什么的，两者有什么区别？" class="headerlink" title="1、JavaScript的call和apply方法是做什么的，两者有什么区别？"></a>1、JavaScript的call和apply方法是做什么的，两者有什么区别？</h1><p>改变this指向。两者后面的参数不一样，call需要把实参按照形参那样传进去，而apply则需要传进去一个arguments。</p><h1 id="2、下面这道题输出什么？为什么这样输出？怎么修改成正确的？"><a href="#2、下面这道题输出什么？为什么这样输出？怎么修改成正确的？" class="headerlink" title="2、下面这道题输出什么？为什么这样输出？怎么修改成正确的？"></a>2、下面这道题输出什么？为什么这样输出？怎么修改成正确的？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        arr[i] = function () &#123;</span><br><span class="line">            document.write(i + &apos; &apos;)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = test();</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    arr[i]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">10 10 10 10 10 10 10 10 10 10</span><br></pre></td></tr></table></figure><p>这个错误是因为数组里面存进去的function里面的i是函数在下面被执行的时候才知道的，那时候的i已经都是10了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        (function(j) &#123;</span><br><span class="line">        arr[j] = function () &#123;</span><br><span class="line">            document.write(j + &apos;&lt;br /&gt;&apos;)</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;(i))</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = test();</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    arr[i]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">arr[0]();</span><br><span class="line">立即执行函数的AO: j = 0</span><br><span class="line">testAO: arr = [f,...,f], i = 10</span><br><span class="line">arr[j] = function() &#123;</span><br><span class="line">document.write(j + &apos; &apos;);</span><br><span class="line">&#125;</span><br><span class="line">里面的j是立即执行函数AO里面的j</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h1 id="3、下面这道题输出什么？"><a href="#3、下面这道题输出什么？" class="headerlink" title="3、下面这道题输出什么？"></a>3、下面这道题输出什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = (</span><br><span class="line">function f() &#123;</span><br><span class="line">return &apos;1&apos;;</span><br><span class="line">&#125;,</span><br><span class="line">function g() &#123;</span><br><span class="line">return 2;</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br><span class="line">console.log(typeof f);</span><br></pre></td></tr></table></figure><p>因为里面按顺序执行，最后执行完g()后把2赋值给f。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">number</span><br></pre></td></tr></table></figure><h1 id="4、下面这道题输出什么？"><a href="#4、下面这道题输出什么？" class="headerlink" title="4、下面这道题输出什么？"></a>4、下面这道题输出什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">bar.apply(null, arguments);</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">foo(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure><p>bar.apply(null, arguments);<br>相当于 bar(arguments);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h1 id="5、下面这道题输出什么？"><a href="#5、下面这道题输出什么？" class="headerlink" title="5、下面这道题输出什么？"></a>5、下面这道题输出什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure><p>这道题不输出，但是也不报错，因为系统会做这样的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure><h1 id="6、下面这道题输出什么？"><a href="#6、下面这道题输出什么？" class="headerlink" title="6、下面这道题输出什么？"></a>6、下面这道题输出什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function b(x, y, a) &#123;</span><br><span class="line">arguments[2] = 10;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">b(1, 2, 3);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>如果函数体改成下面，结果又会是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 10;</span><br><span class="line">console.log(arguments[2]);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>因为实参和形参是对应关系，但不是同一个值</p><h1 id="7、下面这道题输出什么"><a href="#7、下面这道题输出什么" class="headerlink" title="7、下面这道题输出什么"></a>7、下面这道题输出什么</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">if (function f() &#123;&#125;) &#123;</span><br><span class="line">x += typeof(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure><p>if里面的functionf(){}被转换成表达式，而且不返回false，x+=typeof(f)为数字和字符串相加，自动转成字符串，但是f因为被转成表达式了，所以f现在是undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">1undefined</span><br></pre></td></tr></table></figure><h1 id="8、下面表达式的结果是什么？"><a href="#8、下面表达式的结果是什么？" class="headerlink" title="8、下面表达式的结果是什么？"></a>8、下面表达式的结果是什么？</h1><p>undefined == null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但要记住 null == undefined 会返回 true。</span><br></pre></td></tr></table></figure><p>undefined === null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">类型不一样</span><br></pre></td></tr></table></figure><p>isNaN(‘100’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">isNaN()可以理解为以下函数:</span><br><span class="line">function isNaN(num) &#123;</span><br><span class="line">var ret = Number(num);</span><br><span class="line">ret += &apos;&apos;;</span><br><span class="line">if (ret == &apos;NaN&apos;) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseInt(‘1a’) == 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h1 id="9、请输出下面的结果"><a href="#9、请输出下面的结果" class="headerlink" title="9、请输出下面的结果"></a>9、请输出下面的结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;222&apos;;</span><br><span class="line">var a = &#123;</span><br><span class="line">name: &apos;111&apos;,</span><br><span class="line">say: function() &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var func = a.say;</span><br><span class="line">func();               //全局执行</span><br><span class="line">a.say();              //a执行say</span><br><span class="line"></span><br><span class="line">var b = &#123;</span><br><span class="line">name: &apos;333&apos;,</span><br><span class="line">say: function(func) &#123;</span><br><span class="line">func()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b.say(a.say);         //全局执行，b执行say()，但是say里面的func没有调用者</span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say();              //因为把b的say替换成a的say，所以是b执行a的say方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">222</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure><h1 id="10、运行test-和new-test-的结果分别是什么"><a href="#10、运行test-和new-test-的结果分别是什么" class="headerlink" title="10、运行test()和new test()的结果分别是什么?"></a>10、运行test()和new test()的结果分别是什么?</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">function test() &#123;</span><br><span class="line">a = 0;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(this.a);</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">new Test();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">0</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">undefined</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h1 id="11、下面题目输出什么"><a href="#11、下面题目输出什么" class="headerlink" title="11、下面题目输出什么"></a>11、下面题目输出什么</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">var foo;</span><br><span class="line">console.log(foo);</span><br><span class="line">foo = 2;</span><br><span class="line">console.log(foo);</span><br><span class="line">console.log(hello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">undefined</span><br><span class="line">2</span><br><span class="line">报错, hello is not defined</span><br></pre></td></tr></table></figure><h1 id="12、下面题目输出什么"><a href="#12、下面题目输出什么" class="headerlink" title="12、下面题目输出什么"></a>12、下面题目输出什么</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function print() &#123;</span><br><span class="line">var marty = &#123;</span><br><span class="line">name: &apos;marty&apos;,</span><br><span class="line">printName: function() &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var test1 = &#123;</span><br><span class="line">name: &apos;test1&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var test2 = &#123;</span><br><span class="line">name: &apos;test2&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var test3 = &#123;</span><br><span class="line">name: &apos;test3&apos;</span><br><span class="line">&#125;;</span><br><span class="line">test3.printName = marty.printName;</span><br><span class="line">var printName2 = marty.printName.bind(&#123;name: 123&#125;);   </span><br><span class="line">marty.printName.call(test1);                          //test1</span><br><span class="line">marty.printName.apply(test2);                         //test2</span><br><span class="line">printName2()                                          //123</span><br><span class="line">test3.printName();                                    //test3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">123</span><br><span class="line">test3</span><br></pre></td></tr></table></figure><h1 id="13、下面题目输出什么？"><a href="#13、下面题目输出什么？" class="headerlink" title="13、下面题目输出什么？"></a>13、下面题目输出什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var bar = &#123;</span><br><span class="line">    a: &apos;002&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function print() &#123;</span><br><span class="line">    bar.a = &apos;a&apos;;</span><br><span class="line">    Object.prototype.b = &apos;b&apos;;</span><br><span class="line">    return function inner() &#123;</span><br><span class="line">        console.log(bar.a);</span><br><span class="line">        console.log(bar.b);             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print()();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h1 id="14、把一个有序的数组进行乱序"><a href="#14、把一个有序的数组进行乱序" class="headerlink" title="14、把一个有序的数组进行乱序"></a>14、把一个有序的数组进行乱序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">arr.sort(function() &#123;</span><br><span class="line">return Math.random() - 0.5;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="15、写出下面的排序函数"><a href="#15、写出下面的排序函数" class="headerlink" title="15、写出下面的排序函数"></a>15、写出下面的排序函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var lin = &#123;</span><br><span class="line">name: &apos;johnny&apos;,</span><br><span class="line">old: 25</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var chen = &#123;</span><br><span class="line">name: &apos;jolie&apos;,</span><br><span class="line">old: 23</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bao = &#123;</span><br><span class="line">name: &apos;baobao&apos;,</span><br><span class="line">old: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [lin, chen, bao];</span><br><span class="line">arr.sort(function(a, b) &#123;</span><br><span class="line">return a.old - b.old;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="16、下面题目对象最终变成什么？"><a href="#16、下面题目对象最终变成什么？" class="headerlink" title="16、下面题目对象最终变成什么？"></a>16、下面题目对象最终变成什么？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">&apos;2&apos;: &apos;a&apos;,</span><br><span class="line">&apos;3&apos;: &apos;b&apos;,</span><br><span class="line">&apos;length&apos;: 2,</span><br><span class="line">&apos;push&apos;: Array.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.push(&apos;c&apos;);</span><br><span class="line">obj.push(&apos;d&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">var obj = &#123;</span><br><span class="line">&apos;2&apos;: &apos;c&apos;,</span><br><span class="line">&apos;3&apos;: &apos;d&apos;,</span><br><span class="line">length: 4,</span><br><span class="line">&apos;push&apos;: Array.prototype.push</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">按照Array.prototype.push的方法可解答</span><br><span class="line">Array.prototype.push = function(target) &#123;</span><br><span class="line">obj[obj.length] = target;</span><br><span class="line">obj.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17、新建函数type来输出值的类型，区分对象和值"><a href="#17、新建函数type来输出值的类型，区分对象和值" class="headerlink" title="17、新建函数type来输出值的类型，区分对象和值"></a>17、新建函数type来输出值的类型，区分对象和值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function type(target) &#123;</span><br><span class="line">var ret = typeof(target);</span><br><span class="line">    var template = &#123;</span><br><span class="line">        &apos;[object Array]&apos;: &apos;array&apos;,</span><br><span class="line">        &apos;[object Object]&apos;: &apos;object&apos;,</span><br><span class="line">        &apos;[object Number]&apos;: &apos;number - object&apos;,</span><br><span class="line">        &apos;[object Boolean]&apos;: &apos;boolean - object&apos;,</span><br><span class="line">        &apos;[object String]&apos;: &apos;string - object&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (target === null) &#123;</span><br><span class="line">        return &apos;null&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ret == &apos;object&apos;) &#123;</span><br><span class="line">        return template[Object.prototype.toString.call(target)];</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18、-数组去重"><a href="#18、-数组去重" class="headerlink" title="18、 数组去重"></a>18、 数组去重</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 1, 2, 3, 3, &apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;b&apos;];</span><br><span class="line">Array.prototype.unique = function () &#123;</span><br><span class="line">    var temp = &#123;&#125;,</span><br><span class="line">        arr = [],</span><br><span class="line">        len = this.length;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (!temp[this[i]]) &#123;</span><br><span class="line">            temp[this[i]] = &apos;1&apos;;</span><br><span class="line">            arr.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、JavaScript的call和apply方法是做什么的，两者有什么区别？&quot;&gt;&lt;a href=&quot;#1、JavaScript的call和apply方法是做什么的，两者有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;1、JavaScript的c
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>小知识</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/小知识/</id>
    <published>2018-08-14T09:10:00.000Z</published>
    <updated>2018-08-15T06:56:29.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字的toString"><a href="#数字的toString" class="headerlink" title="数字的toString"></a>数字的toString</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">123.toString()</span><br><span class="line">//这个是报错的，因为.的优先级最高，系统会识别成浮点型</span><br><span class="line"></span><br><span class="line">//要写成这样</span><br><span class="line">var num = 123;</span><br><span class="line">num.toString();</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">Object.prototype.toString.call(123)</span><br></pre></td></tr></table></figure><h1 id="js浮点型的精度bug"><a href="#js浮点型的精度bug" class="headerlink" title="js浮点型的精度bug"></a>js浮点型的精度bug</h1><p>可正常计算的范围，小数点前16位，后16位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(0.14 * 100);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">14.000000000000002</span><br></pre></td></tr></table></figure><p>这个是js的bug，所以后续避免直接使用float进行操作</p><p>Math.round() 四舍五入，负数0.5不会+1<br>Math.ceil()  向上取整<br>Math.floor() 向下取整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">如果是直接Math.random().toFixed(2) * 100，就会出现浮点型精度错误的问题</span><br><span class="line">var num = Math.ceil(Math.random().toFixed(2) * 100);</span><br><span class="line">//var num = Math.ceil(Math.random() * 100);</span><br><span class="line">console.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取对象上所有的自有键"><a href="#获取对象上所有的自有键" class="headerlink" title="获取对象上所有的自有键"></a>获取对象上所有的自有键</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;a: &apos;b&apos;, c: &apos;d&apos;&#125;;</span><br><span class="line">console.log(Object.keys(a));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">[&apos;a&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p>一旦经历过var的操作，所得出的属性，这种属性叫做不可配置的属性，是delete不掉的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var num = 123;</span><br><span class="line"></span><br><span class="line">delete num;           // false, 删除不掉</span><br><span class="line">delete window.num;    // false, 删除不掉</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">num: 123;</span><br><span class="line">&#125;</span><br><span class="line">delete obj.num;       // true, 删除掉</span><br><span class="line">delete obj;           // false, 删除不掉</span><br><span class="line"></span><br><span class="line">window.num = 123;</span><br><span class="line">delete window.num;    // true, 删除掉</span><br></pre></td></tr></table></figure><h1 id="es3-0和es5-0"><a href="#es3-0和es5-0" class="headerlink" title="es3.0和es5.0"></a>es3.0和es5.0</h1><p>现在浏览器基本都是基于es3.0的方法加上es5.0的新增方法使用的</p><p>es3.0和es5.0产生冲突的部分</p><p>es5.0严格模式，那么es3.0和es5.0产生冲突的部分就是用es5.0，否则用es3.0的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure><p>不支持with, arguments, callee, func, caller, 变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined)赋值什么就是什么)，拒绝重复属性和参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数字的toString&quot;&gt;&lt;a href=&quot;#数字的toString&quot; class=&quot;headerlink&quot; title=&quot;数字的toString&quot;&gt;&lt;/a&gt;数字的toString&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>基础</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%9B%9E%E9%A1%BE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/回顾基础/</id>
    <published>2018-08-14T08:01:00.000Z</published>
    <updated>2018-08-15T06:56:04.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="严格模式-‘use-strict’"><a href="#严格模式-‘use-strict’" class="headerlink" title="严格模式 ‘use strict’"></a>严格模式 ‘use strict’</h1><p>ECMAScript 5 引入严格模式(‘strict mode’)概念。通过严格模式，在函数内部选择进行较为严格的全局或局部的错误条件检测，使用严格模式的好处是可以提早知道代码中的存在的错误，及时捕获一些可能导致编程错误的ECMAScript行为。在开发中使用严格模式能帮助我们早发现错误。</p><p>将’use strict’放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use struct&apos;;</span><br></pre></td></tr></table></figure><h1 id="声明并输出"><a href="#声明并输出" class="headerlink" title="声明并输出"></a>声明并输出</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var MYAPP = &#123;&#125;;</span><br><span class="line">var a = &apos;Hello World!&apos;;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">var arr = [&apos;小明&apos;, &apos;小红&apos;, &apos;小白&apos;, &apos;小鬼&apos;];</span><br><span class="line">console.log(&apos;欢迎&apos; + arr.slice(0, 2).join(&apos;,&apos;) + &apos;和&apos; + arr[arr.length - 1] + &apos;同学&apos;);</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">name: &apos;小明&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="判断一个属性是否是本身所拥有，而不是继承的"><a href="#判断一个属性是否是本身所拥有，而不是继承的" class="headerlink" title="判断一个属性是否是本身所拥有，而不是继承的"></a>判断一个属性是否是本身所拥有，而不是继承的</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.hasOwnProperty(&apos;name&apos;)</span><br></pre></td></tr></table></figure><h1 id="Array的循环"><a href="#Array的循环" class="headerlink" title="Array的循环"></a>Array的循环</h1><p>由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引</p><p>for … in对Array的循环得到的是String而不是Number。</p><p>for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">a.name = &apos;Johnny&apos;;</span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">console.log(i + &apos;(&apos; + typeof i + &apos;) = &apos; + a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">0(string) = a</span><br><span class="line">1(string) = b</span><br><span class="line">2(string) = c</span><br><span class="line">name(string) = Johnny</span><br></pre></td></tr></table></figure><p>使用for … of循环遍历集合，它只循环集合本身的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">a.name = &apos;Johnny&apos;;</span><br><span class="line">for (var i of a) &#123;</span><br><span class="line">console.log(i + &apos;(&apos; + typeof i + &apos;)&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">a(string)</span><br><span class="line">b(string)</span><br><span class="line">c(string)</span><br></pre></td></tr></table></figure><p>使用forEach()进行遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">a.name = &apos;Johnny&apos;;</span><br><span class="line">a.forEach(function (value, index, array) &#123;</span><br><span class="line">    console.log(value + &apos;,&apos; + index + &apos;,&apos; + array);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">a,0,a,b,c</span><br><span class="line">b,1,a,b,c</span><br><span class="line">c,2,a,b,c</span><br></pre></td></tr></table></figure><h1 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try&#123;&#125; catch(e)&#123;&#125; finany&#123;&#125;</span><br></pre></td></tr></table></figure><p>Error.name的六种值对应的信息：</p><ol><li>EvalError: eval()的使用与定义不一致</li><li>RangeError: 数组越界</li><li>ReferenceError: 非法或不能识别的引用数值</li><li>SyntaxError: 发生语法解析错误</li><li>TypeError: 操作书类型错误</li><li>URIError: URI处理函数使用不当</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function abs(x) &#123;</span><br><span class="line">if (typeof x !== &apos;number&apos;) &#123;</span><br><span class="line">throw &apos;Not a number&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if (x &gt;= 0) &#123;</span><br><span class="line">return x;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">console.log(abs(&quot;11&quot;));</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">console.log(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Not a number</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">console.log(abs(11));</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">console.log(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h1 id="和-区别"><a href="#和-区别" class="headerlink" title="== 和 === 区别"></a>== 和 === 区别</h1><p>简单来说： == 代表相同， === 代表严格相同</p><p>当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false。</p><p>双等号 ==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1) 如果两个值类型相同，再进行三个等号(===)的比较</span><br><span class="line"></span><br><span class="line">(2) 如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</span><br><span class="line">1) 如果一个是null，一个是undefined，那么相等</span><br><span class="line">2) 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</span><br><span class="line"></span><br><span class="line">(3) 如果是对象相比，要地址相同才相等，所以 &#123;&#125; == &#123;&#125;，一定为false</span><br></pre></td></tr></table></figure><p>三等号 ===</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1) 如果类型不同，就一定不相等</span><br><span class="line"></span><br><span class="line">(2) 如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( )来判断）</span><br><span class="line"></span><br><span class="line">(3) 如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</span><br><span class="line"></span><br><span class="line">(4) 如果两个值都是true，或是false，那么相等</span><br><span class="line"></span><br><span class="line">(5) 如果两个值都引用同一个对象或是函数，那么相等，否则不相等</span><br><span class="line"></span><br><span class="line">(6) 如果两个值都是null，或是undefined，那么相等</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;严格模式-‘use-strict’&quot;&gt;&lt;a href=&quot;#严格模式-‘use-strict’&quot; class=&quot;headerlink&quot; title=&quot;严格模式 ‘use strict’&quot;&gt;&lt;/a&gt;严格模式 ‘use strict’&lt;/h1&gt;&lt;p&gt;ECMAScript
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>类数组</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E7%B1%BB%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/类数组/</id>
    <published>2018-08-14T06:42:00.000Z</published>
    <updated>2018-08-15T06:56:16.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li>可以利用属性名模拟数组的特性</li><li>可以动态的增长length属性</li><li>如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充。</li></ol><p>类数组生成的必要条件：</p><p>属性要为索引(数字)属性，必须有length属性，最好加上push</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">0: &apos;a&apos;,</span><br><span class="line">1: &apos;b&apos;,</span><br><span class="line">length: 2,</span><br><span class="line">push: Array.prototype.push,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;可以利用属性名模拟数组的特性&lt;/li&gt;
&lt;li&gt;可以动态的增长length属性&lt;/li&gt;
&lt;li&gt;如果强行让类数组调用push方
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/数组/</id>
    <published>2018-08-14T06:33:00.000Z</published>
    <updated>2018-08-15T06:56:23.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><p>new Array(length/content);</p><p>字面量 []</p><h1 id="数组的读和写"><a href="#数组的读和写" class="headerlink" title="数组的读和写"></a>数组的读和写</h1><p>arr[num]            //不可以溢出读，但是不报错，输出undefined</p><p>arr[num] = xxx      //不可以溢出写   </p><h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><p>下面的方法都是es3.0的方法</p><h5 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h5><p>push:</p><p>在数组后面加一个值或者一串值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2];</span><br><span class="line">arr.push(3);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">arr.push(4, 5, 6);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//模仿push的方法</span><br><span class="line">Array.prototype.push = function () &#123;</span><br><span class="line">    for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        this[this.length] = arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return this.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop:</p><p>在数组后面去除一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.pop();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure><p>shift:</p><p>跟pop的相反，在数组前面去除一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.shift();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[2, 3]</span><br></pre></td></tr></table></figure><p>unshift:</p><p>跟push的相反，在数组前面加一个值或者一串值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [3, 4];</span><br><span class="line">arr.unshift(2);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">arr.unshift(0, 1);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[2, 3, 4]</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>sort:</p><p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [3, 5, 1, 2, 10, 9, 7];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">var arr1 = [3, 5, 1, 2, 10, 9, 7];</span><br><span class="line">arr1.sort(function(a, b) &#123;</span><br><span class="line">return a - b; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 10, 2, 3, 5, 7, 9]      //不传参数就是按照字符编码排序的</span><br><span class="line">[1, 2, 3, 5, 7, 9, 10]</span><br></pre></td></tr></table></figure><p>reverse:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure><p>splice:</p><p>splice(从第几位开始， 截取多少的长度， 在切口处添加新的数据);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 1, 2, 2, 3, 3];</span><br><span class="line">arr.splice(1, 2);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">var arr1 = [1, 1, 2, 2, 3, 3];</span><br><span class="line">arr1.splice(1, 1, 0, 0, 0);</span><br><span class="line">console.log(arr1);</span><br><span class="line"></span><br><span class="line">var arr2 = [1, 2, 3, 5];</span><br><span class="line">arr2.splice(3, 0, 4);</span><br><span class="line">console.log(arr2);</span><br><span class="line"></span><br><span class="line">var arr3 = [1, 2, 3, 4];</span><br><span class="line">arr3.splice(-1, 1);</span><br><span class="line">console.log(arr3);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 2, 3, 3]</span><br><span class="line">[1, 0, 0, 0, 2, 2, 3, 3]</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><h5 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h5><p>concat:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3];</span><br><span class="line">var arr2 = [4, 5, 6];</span><br><span class="line">var arr = arr1.concat(arr2);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p>join</p><p>参数是字符串，不传是按’,’来拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(arr.join(&apos;-&apos;));</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">1-2-3-4-5</span><br></pre></td></tr></table></figure><p>split</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;1-2-3-4-5&quot;;</span><br><span class="line">console.log(string.split(&apos;-&apos;));</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>toString </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">console.log(arr.toString());</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">1,2,3,4,5,6</span><br></pre></td></tr></table></figure><p>slice</p><p>截取，从第几位截取到第几位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(arr.slice(1, 2));</span><br><span class="line">console.log(arr.slice(2));</span><br><span class="line">console.log(arr.slice(-2));</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[2]</span><br><span class="line">[3, 4, 5]</span><br><span class="line">[4, 5]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的定义&quot;&gt;&lt;a href=&quot;#数组的定义&quot; class=&quot;headerlink&quot; title=&quot;数组的定义&quot;&gt;&lt;/a&gt;数组的定义&lt;/h1&gt;&lt;p&gt;new Array(length/content);&lt;/p&gt;
&lt;p&gt;字面量 []&lt;/p&gt;
&lt;h1 id=&quot;数组的读和
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>拷贝</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/拷贝/</id>
    <published>2018-08-14T06:23:00.000Z</published>
    <updated>2018-08-15T06:56:13.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">name: &apos;abc&apos;,</span><br><span class="line">age: 123,</span><br><span class="line">sex: &apos;female&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function clone(origin, target) &#123;</span><br><span class="line">var target = target || &#123;&#125;;</span><br><span class="line">for (var prop in origin) &#123;</span><br><span class="line">if (origin.hasOwnProperty(prop)) &#123;</span><br><span class="line">target[prop] = origin[prop];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样拷贝完的对象里面的引用值会沿用样板对象里面的引用值。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ol><li>遍历对象</li><li>判断是不是原始值 typeof() toString</li><li>判断是数组还是对象</li><li>建立对象的数组或对象</li><li>递归</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;abc&apos;,</span><br><span class="line">    age: 123,</span><br><span class="line">    sex: &apos;female&apos;,</span><br><span class="line">    card: [&apos;visa&apos;, &apos;unionpay&apos;],</span><br><span class="line">    wife: &#123;</span><br><span class="line">        name: &apos;ssss&apos;,</span><br><span class="line">        card: [&apos;visa&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    son: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function deepClone(origin, target) &#123;</span><br><span class="line">    var target = target || &#123;&#125;,</span><br><span class="line">        toStr  = Object.prototype.toString,</span><br><span class="line">        arrStr = &apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">    for (var prop in origin) &#123;</span><br><span class="line">        if (origin.hasOwnProperty(prop)) &#123;</span><br><span class="line">            if (origin[prop] != null &amp;&amp; typeof(origin[prop]) == &apos;object&apos;) &#123;</span><br><span class="line">                target[prop] = toStr.call(origin[prop]) == arrStr ? [] : &#123;&#125;;</span><br><span class="line">                deepClone(origin[prop], target[prop]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                target[prop] = origin[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deepClone(obj, obj1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>继承模式</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/继承模式/</id>
    <published>2018-08-14T06:20:00.000Z</published>
    <updated>2018-08-15T06:56:09.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统形式-–-gt-原型链"><a href="#传统形式-–-gt-原型链" class="headerlink" title="传统形式 –&gt; 原型链"></a>传统形式 –&gt; 原型链</h1><p>过多的继承了没用的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Grand() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var grand = new Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype = grand;</span><br><span class="line">function Father() &#123;</span><br><span class="line">this.name = &apos;Johnny&apos;</span><br><span class="line">&#125;</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = father;</span><br><span class="line">function Son() &#123;</span><br><span class="line">this.old = 2</span><br><span class="line">&#125;</span><br><span class="line">var son = new Son();</span><br></pre></td></tr></table></figure><h1 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h1><ol><li>不能继承借用的构造函数的原型    </li><li>每次构造函数都要多走一个函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">this.name = &apos;Lin &apos; + name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, sex, tel, grade) &#123;</span><br><span class="line">Person.call(this, name, age, sex);</span><br><span class="line">this.tel = tel;</span><br><span class="line">this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017);</span><br></pre></td></tr></table></figure><h1 id="共享原型"><a href="#共享原型" class="headerlink" title="共享原型"></a>共享原型</h1><p>不能随意改动自己的原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Father.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Father() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inherit(Target, Origin) &#123;</span><br><span class="line">Target.prototype = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherit(Son, Father);</span><br><span class="line"></span><br><span class="line">不足：</span><br><span class="line">Son.prototype.sex = &apos;male&apos;;</span><br><span class="line"></span><br><span class="line">var son = new Son();</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">console.log(son.sex);</span><br><span class="line">console.log(father.sex);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">male</span><br><span class="line">male</span><br></pre></td></tr></table></figure><h1 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function inherit(Target, Origin) &#123;</span><br><span class="line">function F() &#123;&#125;;</span><br><span class="line">F.prototype = Origin.prototype;</span><br><span class="line">Target.prototype = new F();</span><br><span class="line">Target.prototype.constuctor = Target;</span><br><span class="line">Target.prototype.uber = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Father() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherit(Son, Father);</span><br><span class="line"></span><br><span class="line">Son.prototype.sex = &apos;male&apos;;</span><br><span class="line"></span><br><span class="line">var son = new Son();</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">console.log(son.sex);</span><br><span class="line">console.log(father.sex);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">male</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><p>更加高端的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function() &#123;</span><br><span class="line">var F = function() &#123;&#125;;</span><br><span class="line">return function(Target, Origin) &#123;</span><br><span class="line">F.prototype = Origin.prototype;</span><br><span class="line">Target.prototype = new F();</span><br><span class="line">Target.prototype.constuctor = Target;</span><br><span class="line">Target.prototype.uber = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">利用闭包实现变量私有化，F存在闭包里面</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;传统形式-–-gt-原型链&quot;&gt;&lt;a href=&quot;#传统形式-–-gt-原型链&quot; class=&quot;headerlink&quot; title=&quot;传统形式 –&amp;gt; 原型链&quot;&gt;&lt;/a&gt;传统形式 –&amp;gt; 原型链&lt;/h1&gt;&lt;p&gt;过多的继承了没用的属性&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>对象枚举</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%AF%B9%E8%B1%A1%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/对象枚举/</id>
    <published>2018-08-14T06:16:00.000Z</published>
    <updated>2018-08-15T06:55:58.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h1><p>会返回原型的自己设置的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">name: &apos;123&apos;,</span><br><span class="line">age: 123,</span><br><span class="line">sex: &apos;male&apos;,</span><br><span class="line">height: 180,</span><br><span class="line">width: 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var prop in obj) &#123;</span><br><span class="line">console.log(prop + &quot; &quot; + typeof(prop) + &quot; &quot; + obj[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">name string 123</span><br><span class="line">age string 123</span><br><span class="line">sex string male</span><br><span class="line">height string 180</span><br><span class="line">width string 100</span><br></pre></td></tr></table></figure><h1 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h1><p>返回一个布尔值，判断对象是否包含特定的自身（非继承）属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">name: &apos;123&apos;,</span><br><span class="line">age: 123,</span><br><span class="line">sex: &apos;male&apos;,</span><br><span class="line">height: 180,</span><br><span class="line">width: 100,</span><br><span class="line">__proto__: &#123;</span><br><span class="line">lastName: &apos;li&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var prop in obj) &#123;</span><br><span class="line">if (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">console.log(prop + &quot; &quot; + typeof(prop) + &quot; &quot; + obj[prop]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">name string 123</span><br><span class="line">age string 123</span><br><span class="line">sex string male</span><br><span class="line">height string 180</span><br><span class="line">width string 100</span><br></pre></td></tr></table></figure><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>用来在运行时指出对象是否是特定类的一个实例。</p><p>A对象是不是B构造函数构造出来的</p><p>看A对象的原型链上有没有B的原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person instanceof Person);</span><br><span class="line">console.log(person instanceof Object);</span><br><span class="line">console.log(person instanceof Array);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;for…in&quot;&gt;&lt;a href=&quot;#for…in&quot; class=&quot;headerlink&quot; title=&quot;for…in&quot;&gt;&lt;/a&gt;for…in&lt;/h1&gt;&lt;p&gt;会返回原型的自己设置的属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>命名空间</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/命名空间/</id>
    <published>2018-08-14T06:15:00.000Z</published>
    <updated>2018-08-15T06:56:18.911Z</updated>
    
    <content type="html"><![CDATA[<p>利用闭包来实现命名空间，模块化开发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var adName = &apos;none&apos;;</span><br><span class="line">var initTopAD = (function initTopAD() &#123;</span><br><span class="line">    var adName = &apos;top&apos;;</span><br><span class="line"></span><br><span class="line">    var addAD = function() &#123;</span><br><span class="line">        console.log(&apos;add &apos; + adName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        addAD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">var initBottomAD = (function () &#123;</span><br><span class="line">    var adName = &apos;bottom&apos;;</span><br><span class="line"></span><br><span class="line">    var addAD = function() &#123;</span><br><span class="line">        console.log(&apos;add &apos; + adName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        addAD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">initTopAD();</span><br><span class="line">initBottomAD();</span><br><span class="line">console.log(adName);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">add top</span><br><span class="line">add bottom</span><br><span class="line">none</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用闭包来实现命名空间，模块化开发&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>this</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/this/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/this/</id>
    <published>2018-08-14T06:11:00.000Z</published>
    <updated>2018-08-15T06:56:35.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数预编译过程-this-gt-window"><a href="#函数预编译过程-this-gt-window" class="headerlink" title="函数预编译过程 this -&gt; window"></a>函数预编译过程 this -&gt; window</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test(c) &#123;</span><br><span class="line">var a = 123;</span><br><span class="line">function b() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">预编译产生AO</span><br><span class="line">AO &#123;</span><br><span class="line">arguments: [1],</span><br><span class="line">this: window,</span><br><span class="line">c: 1,</span><br><span class="line">a: undefines,</span><br><span class="line">b: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test(c) &#123;</span><br><span class="line">// var this = Object.create(test.prototype);</span><br><span class="line">var a = 123;</span><br><span class="line">function b() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">new test(1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">预编译产生AO</span><br><span class="line">AO &#123;</span><br><span class="line">arguments: [1],</span><br><span class="line">this: obj,</span><br><span class="line">c: 1,</span><br><span class="line">a: undefines,</span><br><span class="line">b: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="全局作用域里-this-gt-window"><a href="#全局作用域里-this-gt-window" class="headerlink" title="全局作用域里 this -&gt; window"></a>全局作用域里 this -&gt; window</h1><h1 id="call-apply-可以改变函数运行时this指向"><a href="#call-apply-可以改变函数运行时this指向" class="headerlink" title="call/apply 可以改变函数运行时this指向"></a>call/apply 可以改变函数运行时this指向</h1><h1 id="obj-func-func-里面的this指向obj"><a href="#obj-func-func-里面的this指向obj" class="headerlink" title="obj.func(); func()里面的this指向obj"></a>obj.func(); func()里面的this指向obj</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">show: function() &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;,</span><br><span class="line">name: &apos;abc&apos;</span><br><span class="line">&#125;</span><br><span class="line">obj.show()</span><br></pre></td></tr></table></figure><p>谁调用show，里面的this就指向谁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数预编译过程-this-gt-window&quot;&gt;&lt;a href=&quot;#函数预编译过程-this-gt-window&quot; class=&quot;headerlink&quot; title=&quot;函数预编译过程 this -&amp;gt; window&quot;&gt;&lt;/a&gt;函数预编译过程 this -&amp;gt
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/原型链/</id>
    <published>2018-08-14T06:07:00.000Z</published>
    <updated>2018-08-15T06:56:32.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h1><p>定义：原型是function对象的一个属性，它定义了构造函数制造的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</p><p>利用原型特点和概念，可以提取公有属性</p><p>对象如何查找原型 -&gt; 隐式属性 __proto__</p><p>对象如何查找对象的构造函数 -&gt; constructor</p><p>函数默认就会自动生成prototype这个空对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//或者可以写Person.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">lastName: &apos;Lin&apos;</span><br><span class="line">&#125;</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.show = function () &#123;</span><br><span class="line">console.log(this.lastName + &apos; &apos; + this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;Johnnny&apos;);</span><br><span class="line">person.log();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">Lin Johnny</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">//这里会隐性调用 var this = &#123; __proto__: Person.prototype &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;ccc&apos;;</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">name: &apos;sunny&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以更改__proto__，让它指向其他原型</span><br><span class="line">person.__proto__ = obj;</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">ccc</span><br><span class="line">ccc</span><br><span class="line">sunny</span><br><span class="line">sunny</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">//这里会隐性调用 var this = &#123; __proto__: Person.prototype &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br><span class="line"></span><br><span class="line">//解释为Person.prototype更换了一个新的对象，但是原来的Person.__proto__的指向还是原来的对象</span><br><span class="line">//Person.prototype = &#123;name: &apos;a&apos;&#125;;</span><br><span class="line">//__proto__ = Person.prototype;</span><br><span class="line">//Person.prototype = &#123;name: &apos;b&apos;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">name: &apos;sunny&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person1.__proto__.name);</span><br><span class="line">console.log(person1.name);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">sunny</span><br><span class="line">sunny</span><br></pre></td></tr></table></figure><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>如何构成原型链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Grand() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var grand = new Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype = grand;</span><br><span class="line">function Father() &#123;</span><br><span class="line">this.name = &apos;Johnny&apos;</span><br><span class="line">&#125;</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = father;</span><br><span class="line">function Son() &#123;</span><br><span class="line">this.old = 2</span><br><span class="line">&#125;</span><br><span class="line">var son = new Son();</span><br></pre></td></tr></table></figure><p>特殊的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Grand() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var grand = new Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype = grand;</span><br><span class="line">function Father() &#123;</span><br><span class="line">this.name = &apos;Johnny&apos;,</span><br><span class="line">this.forturn = &#123;</span><br><span class="line">&apos;card1&apos;: &apos;Visa&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = father;</span><br><span class="line">function Son() &#123;</span><br><span class="line">this.old = 2</span><br><span class="line">&#125;</span><br><span class="line">var son = new Son();</span><br><span class="line"></span><br><span class="line">console.log(son.forturn);</span><br><span class="line"></span><br><span class="line">//这个修改是直接获取引用值进行修改</span><br><span class="line">son.forturn.card2 = &apos;UnionPay&apos;;</span><br><span class="line">console.log(son.forturn);</span><br><span class="line"></span><br><span class="line">//这个修改是直接从新赋值</span><br><span class="line">son.forturn = &apos;200&apos;;</span><br><span class="line">console.log(son.forturn);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">&#123;&apos;card1&apos;: &apos;Visa&apos;&#125;</span><br><span class="line">&#123;&apos;card1&apos;: &apos;Visa&apos;, &apos;card2&apos;: &apos;UnionPay&apos;&#125;</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p>Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">name: &apos;a&apos;,</span><br><span class="line">sayName: function() &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">this.name = &apos;b&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">//谁调用sayName这个方法，里面的this就指向谁</span><br><span class="line">console.log(person.sayName());</span><br><span class="line">console.log(Person.prototype.sayName());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>绝大多数对象的最终都会继承自Object.prototype</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;     // --&gt; new Object();</span><br><span class="line">//相当于 var obj = new Object();     少用，尽量用字面量</span><br><span class="line">//obj.__proto__ == Object.prototype</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;&#125;;  //--&gt; Object.prototype</span><br></pre></td></tr></table></figure><p>不会继承Object.prototype的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//null</span><br><span class="line">var obj = Object.create(null);</span><br></pre></td></tr></table></figure><p>Object.create(原型)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//var obj = Object.create(原型);</span><br><span class="line">var obj = &#123;name: &apos;sunny&apos;, age: 123&#125;;</span><br><span class="line">var obj1 = Object.create(obj);</span><br><span class="line">console.log(obj1.__proto__);</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;name: &apos;sunny&apos;, age: 123&#125;;</span><br><span class="line">function Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var person = Object.create(Person.prototype);</span><br><span class="line">console.log(person.__proto__);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">&#123;name: &apos;sunny&apos;, age: 123&#125;</span><br><span class="line">&#123;name: &apos;sunny&apos;, age: 123&#125;</span><br></pre></td></tr></table></figure><h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h1><p>作用，改变this指向。</p><p>call/apply区别，后面传的参数形式不同。</p><ol><li>call 需要把实参按照形参的个数传进去</li><li>apply 需要传一个arguments</li></ol><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。 </p><p>call</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() // ---&gt; test.call();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Person里面的this已经改变成obj了。</span><br><span class="line">Person.call(obj, &apos;cheng&apos;, 300);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">this.name = &apos;Lin &apos; + name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, sex, tel, grade) &#123;</span><br><span class="line">//* var this = &#123;&#125;;</span><br><span class="line">// 改变this的指向，所以用Person里面的方法去封装this，封装后变成</span><br><span class="line">// var this = &#123;name: &apos;Lin Johnny&apos;, age: 123, sex: &apos;male&apos;&#125;;</span><br><span class="line"></span><br><span class="line">Person.call(this, name, age, sex);</span><br><span class="line">this.tel = tel;</span><br><span class="line">this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017);</span><br></pre></td></tr></table></figure><p>apply</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">this.name = &apos;Lin &apos; + name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, sex, tel, grade) &#123;</span><br><span class="line">//* var this = &#123;&#125;;</span><br><span class="line">// 改变this的指向，所以用Person里面的方法去封装this，封装后变成</span><br><span class="line">// var this = &#123;name: &apos;Lin Johnny&apos;, age: 123, sex: &apos;male&apos;&#125;;</span><br><span class="line"></span><br><span class="line">//跟call的区别就是参数不同，apply除了指向，其余参数都包含在数组里面</span><br><span class="line">Person.apply(this, [name, age, sex]);</span><br><span class="line">this.tel = tel;</span><br><span class="line">this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017);</span><br></pre></td></tr></table></figure><p>bind</p><p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var bar = function() &#123;   </span><br><span class="line">  console.log(this.x);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo=&#123;</span><br><span class="line">x:3   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">var func = bar.bind(foo);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型-prototype&quot;&gt;&lt;a href=&quot;#原型-prototype&quot; class=&quot;headerlink&quot; title=&quot;原型 prototype&quot;&gt;&lt;/a&gt;原型 prototype&lt;/h1&gt;&lt;p&gt;定义：原型是function对象的一个属性，它定义了构造函数
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/函数/</id>
    <published>2018-08-14T06:05:00.000Z</published>
    <updated>2018-08-15T06:56:01.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var abs = function(x) &#123;</span><br><span class="line">if (x &gt;= 0) &#123;</span><br><span class="line">return x;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(abs(10));</span><br></pre></td></tr></table></figure><p>这种形式看起来好像是常规的变量赋值语句。但是函数表达式和函数声明的区别在于，函数表达式在使用前必须先赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(abs(10));</span><br><span class="line">function abs(x) &#123;</span><br><span class="line">if (x &gt;= 0) &#123;</span><br><span class="line">return x;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">一般定义函数不会出错</span><br><span class="line"></span><br><span class="line">console.log(abs(10));</span><br><span class="line">var abs = function(x) &#123;</span><br><span class="line">if (x &gt;= 0) &#123;</span><br><span class="line">return x;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">报错，显示undefined is not a function</span><br></pre></td></tr></table></figure><p>造成这种现象是因为解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它的所在的的代码行，才会真正的被解析。</p><p>函数表达式中，创建的函数叫做匿名函数，因为function关键字后面没有标识符。</p><h1 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">var a = 123;</span><br><span class="line">var b = 456;</span><br><span class="line">console.log(a + b);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>两种立即执行函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;&#125;()); W3C 建议第一种</span><br><span class="line">(function()&#123;&#125;)();</span><br></pre></td></tr></table></figure><p>只有表达式才能被执行符号执行, 把函数放在()里面就会被转成表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function () &#123;</span><br><span class="line">&#125;</span><br><span class="line">这不是表达式，这是函数</span><br></pre></td></tr></table></figure><p>函数能够被立即执行，执行完后函数被放弃，test不再代表函数，能被符号执行的函数，就会变成立即执行函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var test = function () &#123;</span><br><span class="line">console.log(&apos;a&apos;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>有正负和叹号或者或与在前面自动变成表达式，所以可以立即执行，然后忽略函数名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(function(test)&#123;</span><br><span class="line">console.log(test);      //输出123，使用()运算符</span><br><span class="line">&#125;(123));</span><br><span class="line"></span><br><span class="line">(function(test)&#123;</span><br><span class="line">console.log(test);      //输出123，使用()运算符</span><br><span class="line">&#125;)(123);</span><br><span class="line"></span><br><span class="line">!function(test)&#123;</span><br><span class="line">console.log(test);      //输出123，使用!运算符</span><br><span class="line">&#125;(123);</span><br><span class="line"></span><br><span class="line">+function(test)&#123;</span><br><span class="line">console.log(test);      //输出123，使用+运算符</span><br><span class="line">&#125;(123);</span><br><span class="line"></span><br><span class="line">-function(test)&#123;</span><br><span class="line">console.log(test);      //输出123，使用-运算符</span><br><span class="line">&#125;(123);</span><br><span class="line"></span><br><span class="line">var fn = function(test)&#123;</span><br><span class="line">console.log(test);      //输出123，使用=运算符</span><br><span class="line">&#125;(123);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a, b, c, d) &#123;</span><br><span class="line">console.log(a + b + c + d);</span><br><span class="line">&#125;(1, 2, 3, 4);</span><br><span class="line">这个不报错，系统把它分成了函数和后面参数，test现在变成了函数。</span><br><span class="line">如果括号里面不加东西，那么就会报错。</span><br></pre></td></tr></table></figure><p>使用立即执行函数的好处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可，如jQuery代码结构。</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="实现公有变量"><a href="#实现公有变量" class="headerlink" title="实现公有变量"></a>实现公有变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eg: 函数累加器</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">var num = 0;</span><br><span class="line">function a() &#123;</span><br><span class="line">num++;</span><br><span class="line">console.log(num);</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数a保留着函数add的AO</span><br><span class="line">var myAdd = add();</span><br><span class="line">myAdd();               1</span><br><span class="line">myAdd();               2</span><br><span class="line">myAdd();               3</span><br></pre></td></tr></table></figure><h2 id="可以做缓存（存储结构）"><a href="#可以做缓存（存储结构）" class="headerlink" title="可以做缓存（存储结构）"></a>可以做缓存（存储结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">var food = &apos;apple&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">eatFood: function() &#123;</span><br><span class="line">if (food != &apos;&apos;) &#123;</span><br><span class="line">console.log(&apos;eating &apos; + food);</span><br><span class="line">food = &quot;&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">console.log(&apos;nothing&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">pushFood: function(myFood) &#123;</span><br><span class="line">food = myFood;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = test();</span><br><span class="line">a.edtFood();              eating apple</span><br><span class="line">a.edtFood();              noting</span><br><span class="line">a.pushFood(&apos;banana&apos;);     </span><br><span class="line">a.edtFood();              eating banana</span><br></pre></td></tr></table></figure><h2 id="可以实现封装，属性私有化"><a href="#可以实现封装，属性私有化" class="headerlink" title="可以实现封装，属性私有化"></a>可以实现封装，属性私有化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, money) &#123;</span><br><span class="line">var lunch = 15;</span><br><span class="line"></span><br><span class="line">this.name = name;</span><br><span class="line">this.money = money;</span><br><span class="line"></span><br><span class="line">this.eat = function() &#123;</span><br><span class="line">this.money = this.money - lunch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.buffet = function() &#123;</span><br><span class="line">lunch = 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.mee = function() &#123;</span><br><span class="line">lunch = 12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.getLunch = function() &#123;</span><br><span class="line">console.log(lunch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;Johnny&apos;, 100);</span><br><span class="line">person.buffet();</span><br><span class="line">person.getLunch();</span><br><span class="line">person.eat();</span><br><span class="line">person.mee();</span><br><span class="line">person.getLunch();</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Block&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        ul &#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">        &#125;</span><br><span class="line">        li:nth-of-type(2n) &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        li:nth-of-type(2n + 1) &#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;d&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var liCollection = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">    for (var i = 0; i &lt; liCollection.length; i++) &#123;</span><br><span class="line">        //闭包的应用</span><br><span class="line">        (function (k) &#123;</span><br><span class="line">            liCollection[k].addEventListener(&quot;click&quot;, function () &#123;</span><br><span class="line">                console.log(k);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;(i))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>对象、包装类</title>
    <link href="http://yoursite.com/2018/08/14/javascript/%E8%AF%AD%E8%A8%80%E7%AF%87/%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/08/14/javascript/语言篇/对象、包装类/</id>
    <published>2018-08-14T06:03:00.000Z</published>
    <updated>2018-08-15T06:55:56.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">name: &apos;Johnny&apos;,</span><br><span class="line">old: 25,</span><br><span class="line">nextYear: function() &#123;</span><br><span class="line">this.old = this.old + 1;</span><br><span class="line">&#125;,</span><br><span class="line">lastYear: function() &#123;</span><br><span class="line">this.old = this.old - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>删除属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete person.old;</span><br></pre></td></tr></table></figure><h1 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、plainObject  对象字面量/对象直接量</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">2、构造函数</span><br><span class="line">2.1、系统自带的构造函数</span><br><span class="line">Object() Array() var obj = new Object();</span><br><span class="line">2.2、自定义</span><br><span class="line">function Car(color) &#123;</span><br><span class="line">//里面会隐性调用，可以选择不写，用*来标识</span><br><span class="line">//* var this = &#123;</span><br><span class="line">//*    __proto__: Car.prototype</span><br><span class="line">//* &#125;;</span><br><span class="line">this.name = &apos;BMW&apos;;</span><br><span class="line">this.wheel = 4;</span><br><span class="line">this.color = color;</span><br><span class="line">//* return this;</span><br><span class="line"></span><br><span class="line">//如果手动return其他值，除非是对象，否则都会自动变成this，比如：</span><br><span class="line">//return [1, 2, 3];    output: [1, 2, 3]</span><br><span class="line">//return 1;            output: Car &#123;name: &apos;BMW&apos;, ...&#125;</span><br><span class="line">&#125;</span><br><span class="line">var car = new Car(&apos;red&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(123);      output: Number&#123;123&#125;</span><br><span class="line">num.abc = &apos;123&apos;;                output: Number&#123;123, abc: &apos;123&apos;&#125;</span><br><span class="line">num + 10;                       output: 133 返回一个整型值</span><br><span class="line"></span><br><span class="line">var bol = new Boolean(&apos;true&apos;); </span><br><span class="line">output: Boolean&#123;[[PrimitiveValue]]: true&#125;</span><br><span class="line"></span><br><span class="line">undefined和null不能设置属性</span><br></pre></td></tr></table></figure><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num = 4;</span><br><span class="line">num.len = 3;    </span><br><span class="line">-&gt; 隐性调用 new Number(4).len = 3; 然后再调用delete</span><br><span class="line"></span><br><span class="line">console.log(num.len);   </span><br><span class="line">-&gt; 隐性调用 new Number(4).len; 然后再输出</span><br><span class="line">output: undefined</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Test:</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.length = 2;</span><br><span class="line">console.log(arr);     output: [1, 2]</span><br><span class="line"></span><br><span class="line">var str = &apos;abcd&apos;;</span><br><span class="line">str.length = 2;</span><br><span class="line">-&gt; 因为str是基础类型，直接给它的属性赋值会隐性调用 new String(&apos;abcd&apos;).len = 2; 然后再调用delete</span><br><span class="line"></span><br><span class="line">console.log(str);     output: abcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">str += 1;                 //str == &apos;abc1&apos;;</span><br><span class="line">var test = typeof str;</span><br><span class="line">if (test.length == 6) &#123;</span><br><span class="line">-&gt; 因为str是基础类型，直接给它的属性赋值会隐性调用 new String(&apos;abc1&apos;).sign = &apos;typeof的返回结果可能为String&apos;; 然后再调用delete</span><br><span class="line"></span><br><span class="line">test.sign = &apos;typeof的返回结果可能为String&apos;;</span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line">-&gt; test.sign会隐性调用 new String(test).sign，然后输出test.sign</span><br><span class="line">console.log(test.sign).     output: undefined</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;声明对象&quot;&gt;&lt;a href=&quot;#声明对象&quot; class=&quot;headerlink&quot; title=&quot;声明对象&quot;&gt;&lt;/a&gt;声明对象&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="javascript随记" scheme="http://yoursite.com/categories/javascript%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>在MRC下的内存管理</title>
    <link href="http://yoursite.com/2018/08/14/objective-c/%E5%9C%A8MRC%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/14/objective-c/在MRC下的内存管理/</id>
    <published>2018-08-14T05:46:00.000Z</published>
    <updated>2018-08-14T14:25:26.610Z</updated>
    
    <content type="html"><![CDATA[<p>以下的解释全部都在MRC环境下</p><ol><li>自己持有的对象，自己所持有。</li><li>非自己生成的对象，自己也能持有。</li><li>不再需要自己持有的对象时，应该要释放。</li><li>非自己持有的对象无法释放。</li></ol><p>对象操作与Objective-C方法的对应</p><table><thead><tr><th style="text-align:left">对象操作</th><th style="text-align:left">Objective-C 方法</th></tr></thead><tbody><tr><td style="text-align:left">生成并持有对象</td><td style="text-align:left">alloc/new/copy/mutableCopy 等方法</td></tr><tr><td style="text-align:left">持有对象</td><td style="text-align:left">retain 方法</td></tr><tr><td style="text-align:left">释放对象</td><td style="text-align:left">release 方法</td></tr><tr><td style="text-align:left">废弃对象</td><td style="text-align:left">dealloc 方法</td></tr></tbody></table><h1 id="自己生成的对象，自己所持有"><a href="#自己生成的对象，自己所持有" class="headerlink" title="自己生成的对象，自己所持有"></a>自己生成的对象，自己所持有</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自己生成并持有对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">id obj = [NSObject new];</span><br><span class="line"></span><br><span class="line">// 自己持有对象</span><br></pre></td></tr></table></figure><p>copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本。与copy方法类似，mutableCopy方法利用基于NSMutableCopying方法约定，由各类实现的mutableCopyWithZone:方法生成并持有对象的副本。两者的区别在于copy方法生成不可变更的对象，而mutableCopy方法生成可变更的对象。虽然是对象的副本，但同alloc、new方法一样，在“自己生成并持有对象”这点上没有改变。</p><h1 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 取得非自己生成并持有的对象</span><br><span class="line">id obj = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">// 取得的对象存在，但自己不持有对象</span><br><span class="line"></span><br><span class="line">[obj retain];</span><br><span class="line">// 调用retain，自己持有对象</span><br></pre></td></tr></table></figure><p>通过retain方法，非自己生成的对象跟用alloc/new/copy/mutableCopy方法生成并持有的对象一样，成为了自己所持有的</p><h1 id="不再需要自己持有的对象时释放"><a href="#不再需要自己持有的对象时释放" class="headerlink" title="不再需要自己持有的对象时释放"></a>不再需要自己持有的对象时释放</h1><p>自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用release方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 自己生成并持有对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">// 自己持有对象</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line"></span><br><span class="line">指向对象的指针仍然被保留在变量obj中，貌似能够访问。</span><br><span class="line">但对象一经释放绝对不可访问。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 取得非自己生成并持有的对象</span><br><span class="line">id obj = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">// 取得的对象存在，但自己不持有对象</span><br><span class="line"></span><br><span class="line">[obj retain];</span><br><span class="line">// 调用retain，自己持有对象</span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line">对象不可再被访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>用alloc/new/copy/mutableCopy方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。</p><p>如果要用某个方法生成对象，并将其返回该方法的调用方，那么它的源代码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject &#123;</span><br><span class="line">//自己生成并持有对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">//自己持有对象</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">如上所示，原封不动地返回用alloc方法生成并持有的对象，就能让调用方也持有该对象。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 取得非自己生成并持有的对象</span><br><span class="line">id obj = [self allocObject];</span><br><span class="line"></span><br><span class="line">//自己持有对象</span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line">对象不可再被访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>那么，调用[NSMutableArray array]方法使取得的对象存在，但自己不持有对象，又是如何实现的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (id)object &#123;</span><br><span class="line">//自己生成并持有对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line">//取得的对象存在，但自己不持有对象</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取得非自己生成的对象，但自己不持有对象</span><br><span class="line">id obj = [self object];</span><br><span class="line"></span><br><span class="line">// 自己持有对象</span><br><span class="line">[obj retain];</span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line">对象不可再被访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>我们使用autorelease方法。用该方法，可以使取得的对象存在，单自己不持有对象。autorelease提供这样的功能，使对象在超出指定的生存范围时能够自动并正确的释放(调用release方法)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下的解释全部都在MRC环境下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己持有的对象，自己所持有。&lt;/li&gt;
&lt;li&gt;非自己生成的对象，自己也能持有。&lt;/li&gt;
&lt;li&gt;不再需要自己持有的对象时，应该要释放。&lt;/li&gt;
&lt;li&gt;非自己持有的对象无法释放。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对
      
    
    </summary>
    
      <category term="objective-c" scheme="http://yoursite.com/categories/objective-c/"/>
    
    
  </entry>
  
  <entry>
    <title>提高调用Objective-C方法的速度</title>
    <link href="http://yoursite.com/2018/08/14/objective-c/%E6%8F%90%E9%AB%98%E8%B0%83%E7%94%A8Objective-C%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%9F%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/08/14/objective-c/提高调用Objective-C方法的速度/</id>
    <published>2018-08-14T05:21:00.000Z</published>
    <updated>2018-08-14T14:24:03.652Z</updated>
    
    <content type="html"><![CDATA[<p>GNUseto中的autorelease实际上是用一种特殊的方法来实现的。这种方法能够高效地运行OSX, iOS应用程序中频繁调用autorelease方法，它被称为”IMP Caching”。</p><p>在进行调用时，为了解决类名/方法名以及取得方法运行时的函数指针，要在框架初始化时对其结果值进行换缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id autorelease_class = [NSAutoreleasePool class];</span><br><span class="line">SEL autorelease_sel = @selector(addObject:);</span><br><span class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</span><br><span class="line"></span><br><span class="line">//实际调用就是使用缓存的结果值。</span><br><span class="line">- (id)autorelease &#123;</span><br><span class="line">(*autorelease_imp)(autorelease_class, autorelease_sel, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是IMP Caching的方法调用。虽然同一下源代码完全相同，但从运行效率上看，即使它依赖于运行环境，一般而言速度也是其他方法的2倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)autorelease &#123;</span><br><span class="line">[NSAutorelesePool addObject:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GNUseto中的autorelease实际上是用一种特殊的方法来实现的。这种方法能够高效地运行OSX, iOS应用程序中频繁调用autorelease方法，它被称为”IMP Caching”。&lt;/p&gt;
&lt;p&gt;在进行调用时，为了解决类名/方法名以及取得方法运行时的函数指针，
      
    
    </summary>
    
      <category term="objective-c" scheme="http://yoursite.com/categories/objective-c/"/>
    
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2018/08/14/objective-c/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/08/14/objective-c/深拷贝和浅拷贝/</id>
    <published>2018-08-14T04:12:00.000Z</published>
    <updated>2018-08-14T14:23:15.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="copy和mutablecopy"><a href="#copy和mutablecopy" class="headerlink" title="copy和mutablecopy"></a>copy和mutablecopy</h1><ol><li><p>copy: 拷贝出来的对象类型总是不可变类型<br>  (例如: NSString, NSDictionary, NSArray)</p></li><li><p>mutableCopy: 拷贝出来的对象类型总是可变类型<br>  (例如: NSMutableString, NSMutableDictionary, NSMutableArray) </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSString *string2 = [string1 copy];</span><br><span class="line">NSString *string3 = [string1 mutableCopy];</span><br><span class="line">NSMutableString *string4 = [string1 mutableCopy];</span><br><span class="line">NSMutableString *string5 = [string1 copy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string2:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string3:</span><br><span class="line">(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string4:</span><br><span class="line">(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string5:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><p>在runtime下NSString的”真身”是<strong>NSCFConstantString，而NSMutableString的”真身”是</strong>NSCFString，然后我们就能很清楚的看到，只要是copy得到的值就是不可变类型，而mutablecopy得到的是可变类型。</p><p>NSTaggedPointerString为苹果在64位对NSString和NSNumber等对象的优化</p><p>#深拷贝和浅拷贝</p><p>imutableObject为不可变对象，如: NSString, NSArray等</p><p>mutableObject为可变对象，如: NSMutableString, NSMutableArray等</p><p><strong>在imutableObject对象中:</strong></p><p>对 immutable 对象进行 copy 操作，是指针复制【浅拷贝】，mutableCopy 操作时内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]           //浅复制</span><br><span class="line">[immutableObject mutableCopy]    //深复制</span><br><span class="line">[mutableObject copy]             //深复制</span><br><span class="line">[mutableObject mutableCopy]      //深复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSString *string2 = [string1 copy];</span><br><span class="line">NSMutableString *string3 = [string1 mutableCopy];</span><br><span class="line"></span><br><span class="line">NSMutableString *string4 = [NSMutableString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">NSString *string5 = [string4 copy];</span><br><span class="line">NSMutableString *string6 = [string1 mutableCopy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string2:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string3:</span><br><span class="line">(__NSCFString *) = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string4:</span><br><span class="line">(__NSCFString *) = 0x000000010342ceb0 @&quot;123&quot;</span><br><span class="line">output-p string5:</span><br><span class="line">(NSTaggedPointerString *) = 0x0000000033323135 @&quot;123&quot;</span><br><span class="line">output-p string6:</span><br><span class="line">(__NSCFString *) = 0x000000010342c830 @&quot;123&quot;</span><br></pre></td></tr></table></figure><p>可以看出，除了对immutable的Copy动作得到的string是浅拷贝外，其他的都是深拷贝。</p><p><strong>在mutableObject对象中:</strong></p><p>对 immutable 对象进行 copy，是指针复制【浅拷贝】， mutableCopy 是内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy] // 浅复制</span><br><span class="line">[immutableObject mutableCopy] //单层深复制</span><br><span class="line">[mutableObject copy] //单层深复制</span><br><span class="line">[mutableObject mutableCopy] //单层深复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSArray *array1 = @[string1];</span><br><span class="line">NSArray *array2 = [array1 copy];</span><br><span class="line">NSMutableArray *array3 = [array1 mutableCopy]; </span><br><span class="line">NSMutableArray *array4 = @[string1];</span><br><span class="line">NSArray *array5 = [array4 copy];</span><br><span class="line">NSMutableArray *array6 = [array4 mutableCopy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array1:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;</span><br><span class="line">output-p array1[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array2:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;</span><br><span class="line">output-p array2[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array3:</span><br><span class="line">(__NSArrayM *) = 0x00000001004002e0 @&quot;1 element&quot;</span><br><span class="line">output-p array3[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array4:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;</span><br><span class="line">output-p array4[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array5:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;</span><br><span class="line">output-p array5[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array6:</span><br><span class="line">(__NSArrayM *) = 0x000000010041ec30 @&quot;1 element&quot;</span><br><span class="line">output-p array6[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br></pre></td></tr></table></figure><p>这里说的单层深复制其实就是所谓的不完全深拷贝，这个跟Java中的深拷贝概念又有所区别，iOS中集合对象的“深拷贝”只拷贝了一个壳，对于壳内的元素是浅拷贝，和java中递归的深拷贝有所不同。</p><h1 id="property中的copy属性"><a href="#property中的copy属性" class="headerlink" title="property中的copy属性"></a>property中的copy属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) NSString *someString;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString</span><br><span class="line">&#123;</span><br><span class="line">  //没有写copy属性时</span><br><span class="line">  _someString = someString;</span><br><span class="line">  //写了copy属性时</span><br><span class="line">  _someString = [someString copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</li><li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</li></ol><p>也就是说，当你加上一个copy属性时，这个对象在被set的时，就不再是改变这个对象的原有内存，而是修改这个对象的不可变副本内存。这样就能够保证这个元素不会被外部修改影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, strong) NSArray *array;</span><br><span class="line"></span><br><span class="line">NSArray *array = @[@1, @2, @3, @4];</span><br><span class="line">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array];</span><br><span class="line">self.array = mutableArray;</span><br><span class="line">[mutableArray removeAllObject];</span><br><span class="line">NSLog(@&quot;%@&quot;, self.array);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&lt;__NSArrayM 0x60800025a9d0&gt;(</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">这就是property里不用copy而用strong的结果，当你确定这个元素是不可变的，那么copy属性还是很有必要的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;copy和mutablecopy&quot;&gt;&lt;a href=&quot;#copy和mutablecopy&quot; class=&quot;headerlink&quot; title=&quot;copy和mutablecopy&quot;&gt;&lt;/a&gt;copy和mutablecopy&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;copy:
      
    
    </summary>
    
      <category term="objective-c" scheme="http://yoursite.com/categories/objective-c/"/>
    
    
  </entry>
  
  <entry>
    <title>何为代码质量</title>
    <link href="http://yoursite.com/2018/08/14/objective-c/%E4%BD%95%E4%B8%BA%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    <id>http://yoursite.com/2018/08/14/objective-c/何为代码质量/</id>
    <published>2018-08-14T04:00:00.000Z</published>
    <updated>2018-08-14T14:22:33.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、使用-i-而不是-i"><a href="#1、使用-i-而不是-i" class="headerlink" title="1、使用 ++i 而不是 i++"></a>1、使用 ++i 而不是 i++</h1><p>经常看到这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;; i++) &#123;&#125;</span><br></pre></td></tr></table></figure><p>单步自增 (或自减) 操作，最好是使用++i而不是i++，效率略高。</p><p>大家应该都知道++i的返回值是自增过后的，而i++的返回值是自增之前的。其实从这点就可以猜测：++i内部实现应该是直接将 i 这块内存 +1 然后返回，而i++需要使用一个局部变量来存储 i 的值，然后 i 加一，最后返回局部变量的值（别告诉我你能先 return 再执行自增）。</p><p>如果某一种语言的i++不能作为左值，那么也可以猜测这个局部变量是用const修饰的。</p><p>所以，i++理论上比++i有更多的消耗，代码就这样写吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;; ++i) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="2、巧用位运算"><a href="#2、巧用位运算" class="headerlink" title="2、巧用位运算"></a>2、巧用位运算</h1><p>位运算效率很高，而且有很多巧妙的用法，这里提出一个需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">   TestEnumA = 1,</span><br><span class="line">   TestEnumB = 1 &lt;&lt; 1,</span><br><span class="line">   TestEnumC = 1 &lt;&lt; 2,</span><br><span class="line">   TestEnumD = 1 &lt;&lt; 3</span><br><span class="line">&#125; TestEnum;</span><br></pre></td></tr></table></figure><p>对于该多选枚举，如何判断该枚举类型的变量是否是复合项？</p><p>如果按照常规的思路，就需要逐项判断是否包含，时间复杂度最差为O(n)。而使用位运算可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestEnum test = …;</span><br><span class="line">if (test == (test &amp; (-test))) &#123;</span><br><span class="line">   //不是复合项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是通过负数二进制的一个特性来判断，看如下分析便一目了然：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test           0000 0100</span><br><span class="line">反码           1111 1011</span><br><span class="line">补码           1111 1100</span><br><span class="line">test &amp; (-test) 0000 0100</span><br></pre></td></tr></table></figure><h1 id="3、灵活使用组合运算符"><a href="#3、灵活使用组合运算符" class="headerlink" title="3、灵活使用组合运算符"></a>3、灵活使用组合运算符</h1><p>不明白有些工程师为什么排斥组合运算符，他们喜欢这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool is = …;</span><br><span class="line">if (is) a = 1;</span><br><span class="line">else a = 2;</span><br></pre></td></tr></table></figure><p>使用三目运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool is = …;</span><br><span class="line">a = is ? 1 : 2;</span><br></pre></td></tr></table></figure><p>其他组合运算符比如 ?: %=等，灵活的使用它们可以让代码更加的简洁清晰。</p><h1 id="4、const-和-static-和宏"><a href="#4、const-和-static-和宏" class="headerlink" title="4、const 和 static 和宏"></a>4、const 和 static 和宏</h1><p>static可以让变量进入静态区，提高变量生命周期至程序结束。值得注意的是，文件中最外层（#include下）的变量本身就是在静态区的，而这种情况使用static是为了变量的私有化。</p><p>const 修饰的变量在常量区不可变，是在编译阶段处理；宏是在预编译阶段执行宏替换。所以频繁使用 const 不会产生额外的内存，而所有使用宏的地方都可能开辟内存，况且，预编译阶段的大量宏替换会带来一定的时间消耗。</p><p>所以笔者的建议是，能用常量的不用宏，比如一个网络请求的 url：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// .h 接口文件</span><br><span class="line">extern NSString * const BaseServer;</span><br><span class="line"></span><br><span class="line">// .m 实现文件</span><br><span class="line">NSString * const BaseServer = @&quot;https://…&quot;;</span><br></pre></td></tr></table></figure><p>值得注意的是，const 是修饰右边内存，所以这里是想要BaseServer字符串指针指向的内容不可变，而不是*BaseServer内容不可变。</p><h1 id="5、空间换时间"><a href="#5、空间换时间" class="headerlink" title="5、空间换时间"></a>5、空间换时间</h1><p>在很多场景中，可以牺牲一定的空间来降低时间复杂度，为了程序的高效运行，工程师可以自行判断是否值得，下面举一个代码例子，判断字符串是否有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL notEmpty(NSString *str) &#123;</span><br><span class="line">   if (!str) return NO;</span><br><span class="line">   static NSSet *emptySet;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       emptySet = [NSSet setWithObjects:@&quot;&quot;, @&quot;(null)&quot;, @&quot;null&quot;, @&quot;&quot;, @&quot;NULL&quot;, nil];</span><br><span class="line">   &#125;);</span><br><span class="line">   if ([emptySet containsObject:str]) return NO;</span><br><span class="line">   if ([str isKindOfClass:NSNull.class]) return NO;</span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个 hash 来提高匹配效率，这在数据较少时可能体现不出优势，甚至会让效率变低，但是在数据量稍大的时候优势就明显了，而且这样写可以避免大量的if-elseif等判断，逻辑更清晰。</p><p>值得注意的是，此处使用static来提升局部变量emptySet的生命周期，而不是将这句代码写在方法体外面。在变量声明时，一定要明确它的使用范围，限定合适的作用域。</p><h1 id="6、容器类型的合理选择"><a href="#6、容器类型的合理选择" class="headerlink" title="6、容器类型的合理选择"></a>6、容器类型的合理选择</h1><p>在 C++ 中，若不需要键值对的 hash ，就使用set而不是map；若不需要排序的集合就使用unordered_set而不是sest。</p><p>归根结底也是对时间复杂度的考虑，选择容器类型时，一定要选择“刚好”能满足需求的，能用更“简单”效率更高的容器就不用“复杂”效率更低的容器。</p><h1 id="7、初始化不要交给编译器"><a href="#7、初始化不要交给编译器" class="headerlink" title="7、初始化不要交给编译器"></a>7、初始化不要交给编译器</h1><p>对于变量的使用，尽量在类或结构体初始化方法中对其赋初值，而不要依赖于编译器。因为在可见的未来，不管是编译器的更新或是代码跨平台移植，这些变量的初始值都不会受编译器影响。</p><h1 id="8、多分支结构处理"><a href="#8、多分支结构处理" class="headerlink" title="8、多分支结构处理"></a>8、多分支结构处理</h1><p>这是一个老生常谈的东西了，多分支结构尽量使用 switch 而不是大量的 if - else if 语句，若非要用 if - else if 来写，则出现频率高的分支优先判断，可以从整体上最大限度的减少判断次数。</p><p>不要小看这些少量的效率提升，放大到整个项目也是有不小的收益。</p><h1 id="9、避免数据同步"><a href="#9、避免数据同步" class="headerlink" title="9、避免数据同步"></a>9、避免数据同步</h1><p>经常会有一些需求，对一系列的数据有很多额外的操作，比如选择、删除、筛选、搜索等。代码设计时，要尽量将所有的操作状态都缓存到同一个数据模型中，而不是使用多个容器数据结构来处理，我们应该尽量避免数据同步防止出错。</p><h1 id="10、合理使用局部指针"><a href="#10、合理使用局部指针" class="headerlink" title="10、合理使用局部指针"></a>10、合理使用局部指针</h1><p>经常会看到这种代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething(city.school.class.jack.name,</span><br><span class="line">            city.school.class.jack.age,</span><br><span class="line">            city.school.class.jack.sex);</span><br></pre></td></tr></table></figure><p>当同一个变量的调用过深且使用频繁时，可以使用一个局部指针来处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *jack = city.school.class.jack;</span><br><span class="line">doSomething(jack.name,</span><br><span class="line">            jack.age,</span><br><span class="line">            jack.sex);</span><br></pre></td></tr></table></figure><p>相对于指针变量所占用的空间来说，代码的简洁和美观度稍显重要一点。</p><h1 id="11、避免滥用单例"><a href="#11、避免滥用单例" class="headerlink" title="11、避免滥用单例"></a>11、避免滥用单例</h1><p>单例作为一种设计模式应用非常广泛，在移动端开发中，有些开发者利用它来实现非缓存传值，笔者认为这是一个错误的做法，使用单例传值的时候你需要管理单例中的数据何时释放与更新，可能会引发数据错乱。</p><p>单例存在的意义应该是缓存数据，而非传值，切勿为了方便滥用单例。</p><h1 id="12、避免滥用继承"><a href="#12、避免滥用继承" class="headerlink" title="12、避免滥用继承"></a>12、避免滥用继承</h1><p>继承本身和解耦思想有些冲突，代码设计中要尽量避免过深的继承关系，因为子类与父类的耦合将无法真正剥离。过深的继承关系会增加调试的困难程度，并且若继承关系设计有缺陷，修改越深的类影响面将会越广，可能带来灾难性的后果。</p><p>可以使用分类的方式做一些通用配置，然后在具体类中简洁的调用一次方法；也可以使用 AOP 思想，hook 住生命周期方法无侵入配置（比如埋点）。</p><p>比如 iOS 开发中，可能会有开发者喜欢写一套基类，实际上只是基于系统的类做了小量的配置，比如BaseViewController、BaseView、BaseModel、BaseViewModel，甚至是BaseTableViewCell。控制器基类可以对栈和导航栏做一些配置，还是有一点使用意义，至于其它的笔者感觉就是过度设计，其实很大意义上BaseViewController也没有存在的必要。</p><p>记住：过多的基类并不是代码规范，那是你囚禁其他开发者的牢笼。</p><h1 id="13、避免过度封装"><a href="#13、避免过度封装" class="headerlink" title="13、避免过度封装"></a>13、避免过度封装</h1><p>提取方法的原则是功能单一性，但若功能本身就是很少的一两句代码可能就没必要额外提取了。在保证代码清晰的情况下，很多时候提取逻辑也是需要酌情考虑的。</p><p>有见过开发者使用一套所谓的简洁配置 UI 的框架，不过就是将 UI 控件的属性封装成链式语法之类的，用起来有种快一些的错觉，殊不知这就是过度封装的典范。</p><p>封装的意义在于简洁的解决一类问题，而非少敲那几个字母，过度封装只会增加其他开发者阅读你代码的成本。</p><p>比如业界知名的 Masonry，使用它时比原生的 layout 快了不止 10 倍，而且代码很简洁易懂，极大的提高了开发效率。</p><h1 id="14、避免过多代码块嵌套"><a href="#14、避免过多代码块嵌套" class="headerlink" title="14、避免过多代码块嵌套"></a>14、避免过多代码块嵌套</h1><p>比如代码中大量的 if - else 嵌套判断，大量的嵌套循环，大量的闭包嵌套。</p><p>出现这种情况首先要考虑的是分支结构处理是否多余？循环是否可以优化时间复杂度？当排除这些可优化项过后，可以做一些方法提取减少大量的代码块嵌套，方便阅读。</p><h1 id="15、时刻注意空值和越界"><a href="#15、时刻注意空值和越界" class="headerlink" title="15、时刻注意空值和越界"></a>15、时刻注意空值和越界</h1><p>写某块代码中，要时刻注意空值和越界的处理，比如给NSDictionary插入空值会崩溃，从NSArray越界取值会崩溃，这些情况要时刻考虑到。</p><p>当然，可能有人会说有方法可以全局避免崩溃。实际上笔者不是很赞同这种做法，这可能会让新手开发者永远发现不了自己代码的漏洞。</p><h1 id="16、时刻注意代码的调用时机和频率"><a href="#16、时刻注意代码的调用时机和频率" class="headerlink" title="16、时刻注意代码的调用时机和频率"></a>16、时刻注意代码的调用时机和频率</h1><p>当你写一块代码时，需要习惯性的思考两个问题：这块代码的共有变量会被多线程访问从而存在安全问题么？这块代码可能会在一个 RunLoop 循环中调用很频繁么？</p><p>对于第一个问题，可能需要使用“锁”来保证线程安全，而锁的选择有一些技巧，比如整形使用原子自增保证线程安全：OSAtomicIncrement32()；调用耗时短的代码使用dispatch_semaphore_t更高效；可能存在重复获取锁时使用递归锁处理…</p><p>对于第二个问题，只需要在合适的地方加入自动释放池 (autoreleasepool) 避免内存峰值就行了。</p><h1 id="17、减少界面代码复用、增加功能代码的复用"><a href="#17、减少界面代码复用、增加功能代码的复用" class="headerlink" title="17、减少界面代码复用、增加功能代码的复用"></a>17、减少界面代码复用、增加功能代码的复用</h1><p>对于大前端来说，界面是项目中重要的组成部分，而有时候设计师给的图中，不同界面有很多相同的元素，看起来一模一样，所以很多工程师偷懒直接复用界面了。</p><p>在这里，笔者建议尽量少的复用界面，宁愿选择复制一份。</p><p>试想，目前版本两个界面相同，你复用了它，当下个版本其中一个界面要调整一下，这时你继续偷懒，加入一些判断来区分逻辑，下一次迭代又增加了差异，你又偷懒加入判断逻辑…… 最终你会发现，这个界面里面已经逻辑爆炸了，拆分成两个界面将变得异常困难。</p><p>而对于功能代码，笔者是提倡多提取，多复用，切记命名规范和适当的注释。</p><h1 id="18、组件的设计技巧"><a href="#18、组件的设计技巧" class="headerlink" title="18、组件的设计技巧"></a>18、组件的设计技巧</h1><p>在封装一些小组件时，一定要形成习惯，不想暴露给使用者的属性和方法不要写在接口文件中，甚至于某些延续父类的方法不想使用者使用，可以如下处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure><p>当然，不用担心组件内部如何获取父类特性，可以通过[super init]来处理。<br>同时，在多人开发中，组件的开放方法名最好加入一些前缀，便于区别，也避免方法重名，最容易导致方法重名的情况就是各种分类里面的方法重复，会带来意想不到的错误。</p><h1 id="19、缓存机制的设计"><a href="#19、缓存机制的设计" class="headerlink" title="19、缓存机制的设计"></a>19、缓存机制的设计</h1><p>不管是任何技术栈的缓存机制设计，都需要一套缓存淘汰算法，使用最广泛的淘汰算法就是 LRU，即是最近最少使用淘汰算法，开发者需要严格的控制磁盘缓存和内存缓存的空间占用。</p><p>在 iOS 开发中，可以使用 YYCache 来处理缓存机制，该框架的源码剖析可见笔者博客：YYCache 源码剖析：一览亮点</p><p>还有一点需要提出的是磁盘缓存的位置问题。iOS 设备沙盒中有 Documents、Caches、Preferences、tmp 等文件夹，其中 Documents 和 Preferences 会被 iCloud 同步。</p><p>Documents 适合存储比较重要的数据；Caches 适合存储大量且不那么重要的数据，比如图片缓存、网络数据缓存啥的；tmp 存储临时文件，重启手机或者内存告急时会被清理；Preferences 是偏好设置，适合存储比较个性化的数据。</p><p>值得注意的是，NSUserDefaults是存储在 Preferences 下的文件，发现有很多开发者为了偷懒频繁的使用NSUserDefaults做任意数据的磁盘缓存，这是一个很不合理的做法，用处不大且大量的数据一般缓存在 Caches 中，就算是从技术角度考虑，NSUserDefaults是以 .plist 形式存储的，不适合大数据存储。</p><h1 id="20、合理选择数字类型"><a href="#20、合理选择数字类型" class="headerlink" title="20、合理选择数字类型"></a>20、合理选择数字类型</h1><p>软件工程师应该清楚自己编写的代码是运行在 32 位还是 64 位的系统上，并且了解编程语言对于各种数字类型的定义。</p><p>在 iOS 领域，CGFloat在 32 位系统中为 float 单精度，64 位系统中为 double 双精度，当将一个NSNumber转换为数字类型时，为了兼容，需要如下写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *number = ...;</span><br><span class="line">CGFloat result = 0;</span><br><span class="line">#if CGFLOAT_IS_DOUBLE</span><br><span class="line">      result  = number.doubleValue;</span><br><span class="line">#else</span><br><span class="line">      result  = number.floatValue;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在使用不同数字类型时，需要考虑数字类型的表示范围，比如能用short处理的就不要用long int。</p><p>同时，数字类型的精度问题往往困扰着新手开发者。不管是单精度 (float) 还是双精度 (double) 它们都是基于浮点计数实现的，包含了符号域、指数域、尾数域，而在计算机的理解里数字就是二进制，所以浮点数基于二进制的科学计数法形如：1.0101 * 2^n ，这可不像十进制那样方便的表示十进制小数，比如在十进制中使用 10^-1 轻松的表示十进制的 0.1 ，而二进制方式却无法实现（试想 2 的几次方等于十进制的 0.1 ？），所以浮点数只能用最大限度的近似值表示这些无法精确表示的小数。</p><p>比如写一句代码 float f = 0.1;打一个断点可以看到它实际的值是：f = 0.100000001。</p><p>和浮点计数相对的是定点计数，定点计数比较直观，比如：10.0101 ，它的弊端就是对于有效位数过多的数字，需要大量的空间来存储。所以为了存储空间的高效利用，使用最广泛的仍然是“不够精确”的基于浮点计数的单精度和双精度类型。</p><p>然而，在一些特定场景下，定点计数仍然能发挥它的优势，比如金钱计算。</p><p>对于金钱计算的处理，往往都是要求绝对准确的，所以在很多语言中都有基于定点计数的数据类型，比如 Java 中的 BigDecimal、Objective-C 中的 NSDecimalNumber，牺牲一些空间和时间来达到精确的计算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、使用-i-而不是-i&quot;&gt;&lt;a href=&quot;#1、使用-i-而不是-i&quot; class=&quot;headerlink&quot; title=&quot;1、使用 ++i 而不是 i++&quot;&gt;&lt;/a&gt;1、使用 ++i 而不是 i++&lt;/h1&gt;&lt;p&gt;经常看到这样的代码：&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="objective-c" scheme="http://yoursite.com/categories/objective-c/"/>
    
    
  </entry>
  
</feed>
