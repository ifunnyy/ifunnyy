<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ifunnyy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-14T14:17:33.196Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Johnny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2018/08/14/objective-c/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/08/14/objective-c/深拷贝和浅拷贝/</id>
    <published>2018-08-14T14:17:00.000Z</published>
    <updated>2018-08-14T14:17:33.196Z</updated>
    
    <content type="html"><![CDATA[<p>#copy和mutablecopy</p><ol><li><p>copy: 拷贝出来的对象类型总是不可变类型<br>  (例如: NSString, NSDictionary, NSArray)</p></li><li><p>mutableCopy: 拷贝出来的对象类型总是可变类型<br>  (例如: NSMutableString, NSMutableDictionary, NSMutableArray) </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSString *string2 = [string1 copy];</span><br><span class="line">NSString *string3 = [string1 mutableCopy];</span><br><span class="line">NSMutableString *string4 = [string1 mutableCopy];</span><br><span class="line">NSMutableString *string5 = [string1 copy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string2:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string3:</span><br><span class="line">(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string4:</span><br><span class="line">(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string5:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><p>在runtime下NSString的”真身”是<strong>NSCFConstantString，而NSMutableString的”真身”是</strong>NSCFString，然后我们就能很清楚的看到，只要是copy得到的值就是不可变类型，而mutablecopy得到的是可变类型。</p><p>NSTaggedPointerString为苹果在64位对NSString和NSNumber等对象的优化</p><p>#深拷贝和浅拷贝</p><p>imutableObject为不可变对象，如: NSString, NSArray等</p><p>mutableObject为可变对象，如: NSMutableString, NSMutableArray等</p><p><strong>在imutableObject对象中:</strong></p><p>对 immutable 对象进行 copy 操作，是指针复制【浅拷贝】，mutableCopy 操作时内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]           //浅复制</span><br><span class="line">[immutableObject mutableCopy]    //深复制</span><br><span class="line">[mutableObject copy]             //深复制</span><br><span class="line">[mutableObject mutableCopy]      //深复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSString *string2 = [string1 copy];</span><br><span class="line">NSMutableString *string3 = [string1 mutableCopy];</span><br><span class="line"></span><br><span class="line">NSMutableString *string4 = [NSMutableString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">NSString *string5 = [string4 copy];</span><br><span class="line">NSMutableString *string6 = [string1 mutableCopy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string2:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string3:</span><br><span class="line">(__NSCFString *) = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string4:</span><br><span class="line">(__NSCFString *) = 0x000000010342ceb0 @&quot;123&quot;</span><br><span class="line">output-p string5:</span><br><span class="line">(NSTaggedPointerString *) = 0x0000000033323135 @&quot;123&quot;</span><br><span class="line">output-p string6:</span><br><span class="line">(__NSCFString *) = 0x000000010342c830 @&quot;123&quot;</span><br></pre></td></tr></table></figure><p>可以看出，除了对immutable的Copy动作得到的string是浅拷贝外，其他的都是深拷贝。</p><p><strong>在mutableObject对象中:</strong></p><p>对 immutable 对象进行 copy，是指针复制【浅拷贝】， mutableCopy 是内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy] // 浅复制</span><br><span class="line">[immutableObject mutableCopy] //单层深复制</span><br><span class="line">[mutableObject copy] //单层深复制</span><br><span class="line">[mutableObject mutableCopy] //单层深复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSArray *array1 = @[string1];</span><br><span class="line">NSArray *array2 = [array1 copy];</span><br><span class="line">NSMutableArray *array3 = [array1 mutableCopy]; </span><br><span class="line">NSMutableArray *array4 = @[string1];</span><br><span class="line">NSArray *array5 = [array4 copy];</span><br><span class="line">NSMutableArray *array6 = [array4 mutableCopy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array1:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;</span><br><span class="line">output-p array1[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array2:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;</span><br><span class="line">output-p array2[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array3:</span><br><span class="line">(__NSArrayM *) = 0x00000001004002e0 @&quot;1 element&quot;</span><br><span class="line">output-p array3[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array4:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;</span><br><span class="line">output-p array4[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array5:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;</span><br><span class="line">output-p array5[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array6:</span><br><span class="line">(__NSArrayM *) = 0x000000010041ec30 @&quot;1 element&quot;</span><br><span class="line">output-p array6[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br></pre></td></tr></table></figure><p>这里说的单层深复制其实就是所谓的不完全深拷贝，这个跟Java中的深拷贝概念又有所区别，iOS中集合对象的“深拷贝”只拷贝了一个壳，对于壳内的元素是浅拷贝，和java中递归的深拷贝有所不同。</p><p>#property中的copy属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) NSString *someString;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString</span><br><span class="line">&#123;</span><br><span class="line">  //没有写copy属性时</span><br><span class="line">  _someString = someString;</span><br><span class="line">  //写了copy属性时</span><br><span class="line">  _someString = [someString copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</li><li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</li></ol><p>也就是说，当你加上一个copy属性时，这个对象在被set的时，就不再是改变这个对象的原有内存，而是修改这个对象的不可变副本内存。这样就能够保证这个元素不会被外部修改影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, strong) NSArray *array;</span><br><span class="line"></span><br><span class="line">NSArray *array = @[@1, @2, @3, @4];</span><br><span class="line">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array];</span><br><span class="line">self.array = mutableArray;</span><br><span class="line">[mutableArray removeAllObject];</span><br><span class="line">NSLog(@&quot;%@&quot;, self.array);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&lt;__NSArrayM 0x60800025a9d0&gt;(</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">这就是property里不用copy而用strong的结果，当你确定这个元素是不可变的，那么copy属性还是很有必要的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#copy和mutablecopy&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;copy: 拷贝出来的对象类型总是不可变类型&lt;br&gt;  (例如: NSString, NSDictionary, NSArray)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mutableCopy: 拷贝出来的对象
      
    
    </summary>
    
      <category term="objective-c" scheme="http://yoursite.com/categories/objective-c/"/>
    
    
  </entry>
  
  <entry>
    <title>arguments</title>
    <link href="http://yoursite.com/2018/08/14/arguments/"/>
    <id>http://yoursite.com/2018/08/14/arguments/</id>
    <published>2018-08-14T04:00:00.000Z</published>
    <updated>2018-08-14T09:20:37.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h1><p>arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性。 </p><p>比如阶乘算法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num = (function (n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * arguments.callee(n - 1);</span><br><span class="line">&#125;(5))</span><br><span class="line"></span><br><span class="line">console.log(num);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">120</span><br></pre></td></tr></table></figure><p>现在已经不推荐使用arguments.callee()；</p><p>原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。</p><p>现在arguments.callee 被弃用了。怎么办，其实很简单，给内部函数一个名字即可（当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num = (function fn(n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * fn(n - 1);</span><br><span class="line">&#125;(5))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;arguments-callee&quot;&gt;&lt;a href=&quot;#arguments-callee&quot; class=&quot;headerlink&quot; title=&quot;arguments.callee&quot;&gt;&lt;/a&gt;arguments.callee&lt;/h1&gt;&lt;p&gt;arguments 的主要用
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="arguments" scheme="http://yoursite.com/tags/arguments/"/>
    
      <category term="callee" scheme="http://yoursite.com/tags/callee/"/>
    
  </entry>
  
</feed>
