{"meta":{"title":"ifunnyy","subtitle":null,"description":"仰天大笑出门去 我辈岂是蓬蒿人","author":"Johnny","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-10-06T11:29:21.000Z","updated":"2018-08-14T09:21:18.333Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-06T11:29:21.000Z","updated":"2018-08-14T09:14:30.320Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"类对象与元类对象&消息传递","slug":"objective-c/类对象与元类对象和消息传递","date":"2019-02-01T05:46:00.000Z","updated":"2019-02-01T09:19:10.904Z","comments":true,"path":"2019/02/01/objective-c/类对象与元类对象和消息传递/","link":"","permalink":"http://yoursite.com/2019/02/01/objective-c/类对象与元类对象和消息传递/","excerpt":"","text":"对象、类对象、元类对象 类对象存储实例方法列表等信息。 元类对象存储类方法列表等信息。 对象、类对象和元类对象之间的关系 每一个对象本质上都是一个类对象的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类对象 每 一个类本质上都是一个对象，类对象其实是元类对象（meteClass）的实例。元类对象定义了类方法的列表。类对象通过类对象的isa指针指向元类 所有的元类最终继承一个根元类对象，根元类对象isa指针指向本身，形成一个封闭的内循环 根元类对象的superclass指针指向根类对象，比如我们调用一个类方法，系统就会从类的元类沿着父类往上查找直到根元类，如果根元类找不到该方法实现，那就会找到根元类的父类根类对象中的同名实例方法来实现。 （面试题）如果我们调用的类方法没有对应的实现，但是有对应同名的实例方法实现，会不会产生实际方法调用？ ​ 会，就是因为根元类对象的superclass指针指向根类对象，当我们在元类对象中找不到对应的类方法实现后，就会沿着跟元类对象superclass指针去到根类对象中查找同名的实例方法实现。 1234567891011121314&gt;#import &quot;Mobile.h&quot;&gt;@interface Phone: Moblie&gt;@end&gt;&gt;@implementation Phone &gt;- (id)init &#123;&gt; self = [super init];&gt; if (self) &#123;&gt; NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));&gt; NSLog(@&quot;%@&quot;, NSStringFromClass([super calss]));&gt; &#125;&gt; return self;&gt;&#125;&gt; （笔试题）请问以上代码输出什么？ ​ Phone，Phone ​ [self class]在编译器层面上会转成objc_msgSend(self, @selector(class))，这时候会从Phone的类对象的方法列表沿superclass指针逐级上找，最终找到根类对象的class实现并返回给调用方。 ​ [super class]在编译器层面上会转成objc_msgSendSuper(objc_super super, @selector(class))，这时候会从Moblie类对象的方法列表开始沿superclass指针逐级上找，最终找到根类对象的class实现并返回给(objc_super super)-&gt;receiver，就是self。 消息传递1void objc_msgSend(void /*id self, SEL op,...*/) 12345[self class]; // 通过编译器转成以下函数调用 objc_msgSend(self, @selector(class)); 123456void objc_msgSendSuper(void /*struct objc_super *super, SEL op, ...*/)struct objc_super &#123; // Specifies an instance of a class __unsafe_unretained id receiver; // 当前对象，self&#125; 12345 [super class];// 通过编译器转成以下函数调用，实际接收者还是objc_super-&gt;receiver，就是对象实例selfobjc_msgSendSuper(objc_super *super, @selector(class)); 缓存查找 给定值的SEL，目标值是对应bucket_t中的IMP。 根据给的方法选择器SEL通过一个函数去映射一个bucket_t在数组当中的位置，这一步骤就是Hash查找（哈希查找）。 Hash查找（哈希查找）就是来解决查找效率的问题。 123f(key) = key &amp; mask;哈希查找实际上就是通过给定一个值，比如方法选择器，然后经过哈希函数算法算出这个值，实际上就是这个值在数组中的一个索引位置。 当前类查找 对于已排序好的列表，采用二分查找算法查找方法对应执行函数。 对于没有排序好的列表，采用一般遍历查找方法查找对应执行函数。 父类逐级查找 消息传递总结 消息传递的流程就是一开始查缓存，缓存没有命中就查当前类的方法列表，没有命中再通过superclass指针逐级往上查父类对象的方法列表，如果都没有再转到消息转发流程。 缓存查找是拿方法选择器通过哈希查找算法算出bucket_t在数组中的索引，通过索引拿到bucket_t中的IMP 当前类方法查找如果遇到排序好的列表，则通过二分查找查找对应的执行函数，如果遇到没有排序好的列表，则通过一般遍历查找执行函数。 逐级父类方法查找是根据superclass指针，首先判断superclass指针是否为nil，如果为nil，至证明无方法命中得到消息转发流程去，如果不为nil，则跟之前步骤一则，先看缓存后再看类方法，如果没有命中，再通过superclass指针继续重复此步骤。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"KVC","slug":"objective-c/KVC","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:42:04.885Z","comments":true,"path":"2019/01/31/objective-c/KVC/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/KVC/","excerpt":"","text":"描述KVC是Key-value coding的缩写。 123- (id)valueForKey:(NSString *)key;- (void)setValue:(id)value forKey:(NSString *)key; valueForKey实现逻辑 系统会判断通过这个key访问的实例变量是否有相应的get方法，有则调用并返回。 没有则会判断实例变量是否存在，存在则获取值并返回。 不存在则会调用valueForUndefinedKey:方法并抛出NSUndefinedKeyException这个未定义key的异常。 关于实例变量是否存在，系统提供了一个可屏蔽的开关+ (BOOL)accessInstanceVariablesDirctly，这个方法默认实现返回的是YES，也就是说与我们这个key相同或者相似的一个成员变量是存在的，那我们认为这个成员变量是存在的，如果我们重写这个方法返回NO，即使我们访问这个key同名的成员变量是存在的，那么我们也没有办法通过这个key去获取对应的值。 Accessor Method is exist （访问器方法是否存在）遵循key相同或者相似原则 get方法，满足驼峰命名 属性名称 对应的成员变量 Instance var （实例变量）同名的实例变量或者相似名称的成员变量 _key _isKey key isKey setValue:ForKey:实现逻辑","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"KVO","slug":"objective-c/KVO","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:42:13.460Z","comments":true,"path":"2019/01/31/objective-c/KVO/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/KVO/","excerpt":"","text":"描述 KVO是Key-value observing的缩写。 KVO是Objective-C对观察者设计模式的又一实现。 Apple使用了isa混写（isa-swizzling）来实现KVO。 机制和原理 当我们注册一个对象的观察者，实际上是调用了系统的addObserver:forKeyPath…这样的方法。 调用了addObserver:forkeyPath…方法后，系统会在运行时动态创建一个NSKVONotifying_Class。 然后会将原来Class的isa指针指向新创建的NSKVONitifying_Class这个类。（这种实际上就是isa-swizzling的标志） NSKVONitifying_Class实际上Class的子类，这样子是为了重写Class的Setter方法。 NSKVONitifying_Class通过重写Class的Setter方法来达到可以通知所有观察者的目的。 （面试题）isa混写技术（isa-swizzling）在KVO是怎么样体现的 ​ 当我们调用addObserve:forKeyPath:之后，系统会在运行时动态创建一个NSKVONitifying这么一个 类。同时将原来类的isa指针指向新创建的类。 代码KVO实践代码MObject 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@interface MObject : NSObject@property (nonatomic, assign) int value;@end #import &quot;MObject.h&quot;@implementation MObject- (instancetype)init&#123; self = [super init]; if (self) &#123; _value = 0; &#125; return self;&#125;- (void)plusOne&#123; _value++;&#125;@end MObserver 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;@interface MObserver : NSObject@end#import &quot;MObserver.h&quot;#import &quot;MObject.h&quot;@implementation MObserver- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; // 判断类和判断keyPath if ([object isKindOfClass:[MObject class]] &amp;&amp; [keyPath isEqualToString:@&quot;value&quot;]) &#123; NSNumber *valueNum = change[NSKeyValueChangeNewKey]; NSLog(@&quot;valueNum = %@&quot;, valueNum); &#125;&#125;@end AppDelegate 123456789101112131415...- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. MObject *mObj = [[MObject alloc] init]; MObserver *mObserver = [[MObserver alloc] init]; // 调用kvo方法监听obj的value属性的变化 [mObj addObserver:mObserver forKeyPath:@&quot;value&quot; options:NSKeyValueObservingOptionNew context:NULL]; // 调用setter方法 mObj.value = mObj.value + 1; return YES;&#125;... 断点调试（证明系统会在运行时动态创建一个NSKVONotifying_Class） 123456789// 在[mObj addObserver:mObserver forKeyPath:@&quot;value&quot; options:NSKeyValueObservingOptionNew context:NULL];前断点，在控制台输入: po object_getClassName(mObj)// 返回: &quot;MObject&quot; // 在[mObj addObserver:mObserver forKeyPath:@&quot;value&quot; options:NSKeyValueObservingOptionNew context:NULL];后断点，在控制台输入: po object_getClassName(mObj)// 返回: &quot;NSKVONotifying_MObject&quot; 重写的Setter添加的方法123- (void)willChangeValueForKey:(NSString *)key;- (void)didChangeValueForKey:(NSString *)key; NSKVONotifying_Class的setter实现 123456789- (void)setValue:(id)obj&#123; [self willChangeValueForKey:@&quot;keyPath&quot;]; // 调用父类实现，也即原来的实现 [super setValue:obj]; [self didChangeValueForKey:@&quot;keyPath&quot;];&#125; （面试题）通过kvc设置value能否生效？ ​ 可以 （面试题）为什么通过kvc设置value能够生效？ ​ 用kvc设置最终会到value的setter方法 （面试题）通过成员变量直接复制value能否生效？ ​ 不可以，比如_value += 1; ​ 但是可以手动达到kvo的效果，比如： ​ - (void)pulsOne ​ { ​ [self willChangeValueForKey:@”value”]; ​ _value += 1; ​ [self didChangeValueForKey:@”value”]; ​ } 总结 使用setter方法改变之KVO才会生效。 使用setValue:forKey:改变值KVO才会生效。 成员变量直接修改需手动添加KVO才会生效。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"Objective-C面试总结","slug":"objective-c/Objective-C面试总结","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:42:19.231Z","comments":true,"path":"2019/01/31/objective-c/Objective-C面试总结/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/Objective-C面试总结/","excerpt":"","text":"技术要点 笔试面试题MRC下如何重写retain修饰变量的setter方法？12345678@property (nonatiomic, retain) id obj;- (void)setObj:(id)obj &#123; // 为啥要加这个判断，因为如果obj是_obj的话，在下面[_obj release]的时候就会把自己本身给释放掉，这时候程序就会出现异常奔溃。 if (_obj != obj) &#123; [_obj release]; _obj = [obj retain]; &#125;&#125; 请简述分类实现原理分类实现原理是由运行时来决议的，然后不同分类含有同名方法最后由谁实现取决于最后参与编译的是哪个分类，如果分类添加的方法刚好是宿主类的同名方法，那分类方法会覆盖宿主类的同名方法，这里的覆盖只是由于消息传递的过程中优先查找数组靠前位置的同名方法。实际上宿主类同名方法是存在的。 KVO内部实现原理比如某个类调用addObserver:forKeyPath:这个方法后，系统就会在运行时动态创建该类的一个派生类NSNotifying，这个派生类会重写基类中任何被观察属性的setter方法。通过重写的setter方法实现真正的通知机制。(A-&gt;NSNotifying_A) Foundation对象与Core Foundation对象有什么区别 Foundation对象是OC的，Core Foundation对象是C对象的 数据类型之间的转换 ARC: __bridge_retained、__bridge_transfer 非ARC：__bridge","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"代理（Delegate）","slug":"objective-c/代理（Delegate）","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:41:08.397Z","comments":true,"path":"2019/01/31/objective-c/代理（Delegate）/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/代理（Delegate）/","excerpt":"","text":"描述 准确的说是一种软件设计模式，代理模式。 iOS当中以@protocol形式体现。 传递方式一对一。 工作流程 （面试题）代理中的方法是必须实现的么 ​ 不一定，看方法的标识，如果是@required的话就是必须实现，@optional就是可选实现。 注意点 一般代理的声明为weak，以规避循环引用。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"关联对象（Associations）","slug":"objective-c/关联对象（Associations）","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:41:30.904Z","comments":true,"path":"2019/01/31/objective-c/关联对象（Associations）/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/关联对象（Associations）/","excerpt":"","text":"关联对象作用 使用关联对象可以给分类添加“成员变量”。 为现有的类添加私有变量以帮助实现细节。 为现有的类添加公有属性 为 KVO 创建一个关联的观察者 函数12345678// 通过指定的key去object对象中读取关联值id objc_getAssociatedObject(id object, const void *key);// 存入一个值，使这个值和key相映射，然后把这个映射关系通过policy关联到object对象上，传入nil则移除已有的关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 根据指定对象去移除它所有的关联对象，慎用，因为这样会移除掉别人添加的关联对象void objc_removeAssociatedObjects(id object) 关联对象的本质关联对象由系统提供的AssociationsManager管理并在AssociationsHashMap存储。 所有对象的关联内容都在同一个全局容器中。 （面试题）用关联对象实现的为分类添加的“成员变量”储存到哪？ ​ 都放在AssocationsManager里面的AssociationHashMap存储。并且所有的关联内容无论是为哪个分类创建的对象都会放在同一个全局容器里面。 关联策略 关联策略 等价属性 说明 OBJC_ASSOCIATION_ASSIGN @property (assign) or @property (unsafe_unretained) 弱引用关联对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (strong, nonatomic) 强引用关联对象，且为非原子操作 OBJC_ASSOCIATION_COPY_NONATOMIC @property (copy, nonatomic) 复制关联对象，且为非原子操作 OBJC_ASSOCIATION_RETAIN @property (strong, atomic) 强引用关联对象，且为原子操作 OBJC_ASSOCIATION_COPY @property (copy, atomic) 复制关联对象，且为原子操作 const void *keyconst void *key类型通常都是通常都是会采用静态变量来作为关键字，可以自己创建，也可以使用@selector(XXX)。 第一种 123static const char nameKey;objc_setAssociatedObject(self, &amp;nameKey, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 第二种 1234objc_setAssociatedObject(self, @selector(function), name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);// 或者objc_setAssociatedObject(self, _cmd, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);// _cmd的作用域只在当前方法里，直指当前方法名@selector。 DEMO1234567891011// UIButton+Block.h#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(id sender);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end 12345678910111213141516171819202122// UIButton+Block.m#import \"UIButton+Block.h\"#import &lt;objc/runtime.h&gt;- (void)handelWithBlock:(btnBlock)block &#123; if (block) &#123; // @selector(btnAction:) objc_setAssociatedObject(self, @selector(btnAction:), block, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction:(id)sender &#123; btnBlock block = objc_getAssociatedObject(self, @selector(btnAction:)); if (block) &#123; block(sender); &#125;&#125;@end","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"分类（Category）","slug":"objective-c/分类（Category）","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:41:20.218Z","comments":true,"path":"2019/01/31/objective-c/分类（Category）/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/分类（Category）/","excerpt":"","text":"分类做了那些事 声明私有方法 分解体积庞大的类文件 把framework的私有方法公开 特点 运行时决议，通过runtime添加 可以为系统类添加分类 分类中都可以添加那些内容 实例方法 类方法 协议 属性（在分类中定义属性，实际上只是声明对应的get方法和set方法，并没有为我们在类中添加示实例变量） 成员变量（使用关联对象技术） （面试题）分类有多个的情况下，各个分类都有一个同名的实例方法，最终哪个会失效 ​ 最后编译的分类当中的方法会生效 分类源码结构 总结 分类添加的方法可以“覆盖”原类方法 同名分类方法谁能生效取决于编译顺序 名字相同的分类会引起编译报错","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"属性关键字","slug":"objective-c/属性关键字","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:41:46.852Z","comments":true,"path":"2019/01/31/objective-c/属性关键字/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/属性关键字/","excerpt":"","text":"属性关键字分为哪几类 读写权限 readonly readwrite (默认) 原子性 atomic (默认) nonatomic 引用计数 retain/strong (默认) retain一般在MRC中使用，strong一般在ARC中使用 都是用来修饰对象 assign/unsafe_unretained assign: 修饰基本数据类型，如int，BOOL等。 assign: 修饰对象类型时，不改变其引用计数。 assign所修饰的对象，在被释放之后，assign指针仍指向原地址，这个时候如果通过assign指针继续访问原对象，会产生悬垂指针导致内存泄漏，程序异常。 unsafe_unretained在MRC中使用较多，ARC基本不用 weak 不改变被修饰对象的引用计数。 所指对象在被释放之后会自动置为nil。 copy （面试题）被atomic修饰的属性有什么意义？ ​ 保证赋值和获取是线程安全的（这里的赋值和获取是对成员属性直接赋值和获取，并不包括操作访问），比如被atomic修饰的数组，对它进行赋值和获取是可以保证线程安全，但是对这个数组做操作，比如增加和移除对象，这样就不能保证线程安全。 （面试题）assign和weak他们之间的区别有哪些 ​ 一、weak可以修饰对象，而assign既可以修饰对象，也可以修饰基本数据类型。 ​ 二、assign所修饰的对象被释放后，assign指针仍指向原来的内存地址，而weak所修饰的对象被释放后，会自动设置为nil。 copy关键字要点 源对象类型 拷贝方式 目标对象类型 拷贝类型（深/浅） mutable对象 copy 不可变 深拷贝 mutable对象 mutableCopy 可变 深拷贝 immutable对象 copy 不可变 浅拷贝 immutable对象 mutableCopy 可变 深拷贝 可变对象的copy和mutableCopy都是深拷贝 不可变对象的copy是浅拷贝，mutableCopy是深拷贝 copy方法返回的都是不可变对象 浅拷贝浅拷贝就是对内存地址的复制，让目标对象指针的源对象指向同一片内存空间。 浅拷贝会增加被拷贝对象的引用计数 不要产生新的内存空间 深拷贝深拷贝让目标对象指针和源对象指针指向两片内容相同的内存空间。 深拷贝不会增加被拷贝对象的引用计数 深拷贝产生了一个内存分配，出现了两块内存。 （面试题）说出深拷贝和浅拷贝的不同 ​ 是否开辟了新的内存空间，深拷贝会，浅拷贝不会。 ​ 是否影响引用计数，深拷贝不会，浅拷贝会。 （面试题）@property(copy)NSMutableArray* array，这样声明会产生什么问题？ ​ 会导致程序异常。 ​ 如果赋值过来的是NSMutableArray，copy之后是NSArray。 ​ 如果赋值过来的是NSArray，copy之后是NSArray。 ​","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"扩展（Extension）","slug":"objective-c/扩展（Extension）","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:32:23.295Z","comments":true,"path":"2019/01/31/objective-c/扩展（Extension）/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/扩展（Extension）/","excerpt":"","text":"扩展能做什么 声明私有属性 声明私有变量 声明私有成员变量 扩展特点 编译时决议。 只以声明的形式存在，多数情况下寄生于宿主类的.m中。 不能为系统类添加扩展。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"通知（NSNotification）","slug":"objective-c/通知（NSNotification）","date":"2019-01-31T05:46:00.000Z","updated":"2019-01-31T09:41:55.866Z","comments":true,"path":"2019/01/31/objective-c/通知（NSNotification）/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/通知（NSNotification）/","excerpt":"","text":"特点 使用观察者模式来实现的，用于跨层传递消息的机制。 传递方式为一对多。 如何实现通知机制NSNotificaitioncenter内部应该是服务一个Map表或者字典，key是notificationName，value是一个数组列表Observers_list，Observers_list里面每个成员应该包含注册通知的观察者，其次还得包含关于观察者调用的方法。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"runtime数据结构","slug":"objective-c/Runtime数据结构","date":"2019-01-30T16:12:00.000Z","updated":"2019-02-01T09:13:25.744Z","comments":true,"path":"2019/01/31/objective-c/Runtime数据结构/","link":"","permalink":"http://yoursite.com/2019/01/31/objective-c/Runtime数据结构/","excerpt":"","text":"数据结构 objc_object 对象 objc_class 类，类对象 isa指针 共用体isa_t method_t 方法定义 objc_object 平时我们使用的所有对象都是id类型的，对应runtime中objc_object结构体 isa_t 共用体 关于isa操作相关 比如通过objc_object这个结构体来获取它的isa所指向的类对象，包括通过类对象的isa指针获取它的元类对象 弱引用相关 比如标记一个对象是否曾经弱引用指针 关联对象相关 比如这个对象我们为它设置了一些关联属性和关联方法 内存管理相关 比如MRC下的retain和release，或者ARC和MRC下都可以用到的autoreleasepool objc_class OC中所使用的Class实际上对应的是runtime中objc_class这个结构体 objc_class继承自objc_object，所以Class是个对象，类对象 Class superClass 指向父类对象 cache_t cache 方法缓存结构 class_data_bits_t bits 实际关于一个类定义所定义的变量、属性，包括方法都在bits里面 （面试题）Class是否是对象 ​ 是，类对象，因为它继承自objc_object。 isa指针共用体isa_t isa_t在32位或者64位架构上面，实际下都是一串32位或者64位0或者1数字 指针型isa isa的值代表Class的地址 非指针型isa isa的值的部分代表Class的地址 剩下的部分可以存储一些其他内容来达到节省内存的目的 isa指向 关于对象，其指向类对象。 实例 —isa—&gt; Class 我们通过一个实例去调用实例方法，就是通过对象的isa指针到它的类对象进行方法查找 关于类对象，其指向元类对象（MeteClass）。 Class —isa—&gt; MetaClass 我们通过一个类去调用类方法，就是通过类对象的isa指针到它的元类去进行方法查找 cache_t 用于快速查找方法执行函数 比如我们调用一个方法的时候，如果之前调用并缓存起来，就不用到方法列表进行遍历查找 是可增量扩展的哈希表结构 会根据存储增量去扩大内存空间 用哈希表是为了增加查找效率 是局部性原理的最佳应用 把平时调用频次最高的方法放在缓存中 时间局部性是指被引用过的存储器位置很可能会被再次引用 空间局部性是指被引用过的存储器位置附近的数据很可能将被引用 class_data_bits_t class_data_bits_t主要是对class_rw_t的封装 class_rw_t可读可写，就说明我们可以随时创建分类来给这个类添加属性和方法 class_rw_t代表了类相关的读写信息，对class_ro_t的封装 class_ro_t只读，当我们创建一个类的时候为它添加的成员变量和方法列表，在之后就没办法修改了 class_ro_t代表了类相关的只读信息 class_rw_t 我们在为一个类添加分类的协议、属性和方法就是对应上图的protocols、properties和methods protocols、properties和methods这三个结构都继承于list_array_tt这个二维数组 class_ro_t name：类名。 平时我们用的NSClassFromString(@”ClassName”)，通过String获取一个类 ivars：类的成员变量 properties：类的属性 原始定义的属性 protocols：类遵从的协议 原始遵从的协议 methodList：类添加的方法列表 原始定义的方法 class_ro_t的方法列表和class_rw_t的方法列表是有区别的，前者是一维数组，后者是二维数组 method_t IMP：无类型的函数指针，函数体。 IMP指针是指向实现函数的指针, 通过SEL取得IMP, objc_msgSend来执行实现方法。 Type Encodings const char *types; 不可变的字符指针 第一位永远都是函数的返回值 调用一个方法，在runtime层面上都会转成objc_msgsend这样的函数调用，函数调用的第一个参数和第二个参数是固定的，并且是不可变的，第一个参数必须是id类型的，为消息的接收者，比如self这个对象，第二个是选择器SEL。 整体数据结构","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"ipa 重新签名","slug":"ios/ipa重签","date":"2018-08-16T08:56:00.000Z","updated":"2018-08-16T08:57:04.998Z","comments":true,"path":"2018/08/16/ios/ipa重签/","link":"","permalink":"http://yoursite.com/2018/08/16/ios/ipa重签/","excerpt":"","text":"批量替换脚本：https://github.com/ifunnyy/ipa-batch-signature-again ipa 重签的操作主要分为以下几步： 先将ipa包进行解压 删除Payload/xxx.app/_CodeSignature里面的文件 替换embedded.mobileprovision 生成entitlements.plist 进行重新签名 重新打包 假设证书和ipa包都在同个目录下 先将ipa包进行解压1unzip xxx.ipa 删除Payload/xxx.app/_CodeSignature里面的文件1rm -fr Payload/xxx.app/_CodeSignature/ 替换embedded.mobileprovision1cp embedded.mobileprovision Payload/xxx.app/embedded.mobileprovision 生成entitlements.plist123security cms -D -i embedded.mobileprovision &gt; entitlements_full.plist/usr/libexec/PlistBuddy -x -c &apos;Print:Entitlements&apos; entitlements_full.plist &gt; entitlements.plist 进行重新签名1/usr/bin/codesign -f -s &quot;证书名称&quot; --entitlements entitlements.plist Payload/xxx.app/ 重新打包1zip -r xxx.ipa Payload/","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[]},{"title":"题目","slug":"javascript/语言篇/题目","date":"2018-08-14T09:16:00.000Z","updated":"2018-08-15T06:56:26.391Z","comments":true,"path":"2018/08/14/javascript/语言篇/题目/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/题目/","excerpt":"","text":"1、JavaScript的call和apply方法是做什么的，两者有什么区别？改变this指向。两者后面的参数不一样，call需要把实参按照形参那样传进去，而apply则需要传进去一个arguments。 2、下面这道题输出什么？为什么这样输出？怎么修改成正确的？1234567891011121314function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; document.write(i + &apos; &apos;) &#125;; &#125; return arr;&#125;var arr = test();for (var i = 0; i &lt; 10; i++) &#123; arr[i]();&#125; 12output:10 10 10 10 10 10 10 10 10 10 这个错误是因为数组里面存进去的function里面的i是函数在下面被执行的时候才知道的，那时候的i已经都是10了。 12345678910111213141516171819202122232425function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i++) &#123; (function(j) &#123; arr[j] = function () &#123; document.write(j + &apos;&lt;br /&gt;&apos;) &#125;; &#125;(i)) &#125; return arr;&#125;var arr = test();for (var i = 0; i &lt; 10; i++) &#123; arr[i]();&#125;解析：arr[0]();立即执行函数的AO: j = 0testAO: arr = [f,...,f], i = 10arr[j] = function() &#123; document.write(j + &apos; &apos;);&#125;里面的j是立即执行函数AO里面的j 12output:0 1 2 3 4 5 6 7 8 9 3、下面这道题输出什么？123456789var f = ( function f() &#123; return &apos;1&apos;; &#125;, function g() &#123; return 2; &#125;)();console.log(typeof f); 因为里面按顺序执行，最后执行完g()后把2赋值给f。 12output:number 4、下面这道题输出什么？1234567function foo() &#123; bar.apply(null, arguments);&#125;function bar() &#123; console.log(arguments);&#125;foo(1, 2, 3, 4, 5); bar.apply(null, arguments);相当于 bar(arguments); 12output:[1, 2, 3, 4, 5] 5、下面这道题输出什么？123function foo() &#123; console.log(arguments);&#125;(1, 2, 3, 4, 5); 这道题不输出，但是也不报错，因为系统会做这样的转换。 123456function foo() &#123; console.log(arguments);&#125;(1, 2, 3, 4, 5); 6、下面这道题输出什么？12345function b(x, y, a) &#123; arguments[2] = 10; console.log(a);&#125;b(1, 2, 3); 12output:10 如果函数体改成下面，结果又会是什么？ 12a = 10;console.log(arguments[2]); 12output:10 因为实参和形参是对应关系，但不是同一个值 7、下面这道题输出什么123456var x = 1;if (function f() &#123;&#125;) &#123; x += typeof(f);&#125;console.log(x); if里面的functionf(){}被转换成表达式，而且不返回false，x+=typeof(f)为数字和字符串相加，自动转成字符串，但是f因为被转成表达式了，所以f现在是undefined。 12output:1undefined 8、下面表达式的结果是什么？undefined == null 1234output:true比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但要记住 null == undefined 会返回 true。 undefined === null 1234output:false类型不一样 isNaN(‘100’) 12345678910111213output:falseisNaN()可以理解为以下函数:function isNaN(num) &#123; var ret = Number(num); ret += &apos;&apos;; if (ret == &apos;NaN&apos;) &#123; return true; &#125; else &#123; return false; &#125;&#125; parseInt(‘1a’) == 1 12output:true 9、请输出下面的结果1234567891011121314151617181920var name = &apos;222&apos;;var a = &#123; name: &apos;111&apos;, say: function() &#123; console.log(this.name); &#125;&#125;var func = a.say;func(); //全局执行a.say(); //a执行sayvar b = &#123; name: &apos;333&apos;, say: function(func) &#123; func() &#125;&#125;b.say(a.say); //全局执行，b执行say()，但是say里面的func没有调用者b.say = a.say;b.say(); //因为把b的say替换成a的say，所以是b执行a的say方法 12345output:222111222333 10、运行test()和new test()的结果分别是什么?12345678910111213var a = 5;function test() &#123; a = 0; console.log(a); console.log(this.a); var a; console.log(a);&#125;test();new Test(); 12345678output:0500undefined0 11、下面题目输出什么123456789function test() &#123; var foo; console.log(foo); foo = 2; console.log(foo); console.log(hello);&#125;test(); 1234output:undefined2报错, hello is not defined 12、下面题目输出什么1234567891011121314151617181920212223function print() &#123; var marty = &#123; name: &apos;marty&apos;, printName: function() &#123; console.log(this.name); &#125; &#125;; var test1 = &#123; name: &apos;test1&apos; &#125;; var test2 = &#123; name: &apos;test2&apos; &#125;; var test3 = &#123; name: &apos;test3&apos; &#125;; test3.printName = marty.printName; var printName2 = marty.printName.bind(&#123;name: 123&#125;); marty.printName.call(test1); //test1 marty.printName.apply(test2); //test2 printName2() //123 test3.printName(); //test3&#125; 1234test1test2123test3 13、下面题目输出什么？1234567891011121314var bar = &#123; a: &apos;002&apos;&#125;function print() &#123; bar.a = &apos;a&apos;; Object.prototype.b = &apos;b&apos;; return function inner() &#123; console.log(bar.a); console.log(bar.b); &#125;&#125;print()(); 12ab 14、把一个有序的数组进行乱序1234var arr = [1, 2, 3, 4, 5, 6, 7];arr.sort(function() &#123; return Math.random() - 0.5;&#125;); 15、写出下面的排序函数12345678910111213141516171819var lin = &#123; name: &apos;johnny&apos;, old: 25&#125;var chen = &#123; name: &apos;jolie&apos;, old: 23&#125;var bao = &#123; name: &apos;baobao&apos;, old: 3&#125;var arr = [lin, chen, bao];arr.sort(function(a, b) &#123; return a.old - b.old;&#125;) 16、下面题目对象最终变成什么？12345678var obj = &#123; &apos;2&apos;: &apos;a&apos;, &apos;3&apos;: &apos;b&apos;, &apos;length&apos;: 2, &apos;push&apos;: Array.prototype.push&#125;obj.push(&apos;c&apos;);obj.push(&apos;d&apos;); 12345678910111213output:var obj = &#123; &apos;2&apos;: &apos;c&apos;, &apos;3&apos;: &apos;d&apos;, length: 4, &apos;push&apos;: Array.prototype.push&#125;按照Array.prototype.push的方法可解答Array.prototype.push = function(target) &#123; obj[obj.length] = target; obj.length++;&#125; 17、新建函数type来输出值的类型，区分对象和值12345678910111213141516171819function type(target) &#123; var ret = typeof(target); var template = &#123; &apos;[object Array]&apos;: &apos;array&apos;, &apos;[object Object]&apos;: &apos;object&apos;, &apos;[object Number]&apos;: &apos;number - object&apos;, &apos;[object Boolean]&apos;: &apos;boolean - object&apos;, &apos;[object String]&apos;: &apos;string - object&apos; &#125; if (target === null) &#123; return &apos;null&apos;; &#125; if (ret == &apos;object&apos;) &#123; return template[Object.prototype.toString.call(target)]; &#125; return ret;&#125; 18、 数组去重1234567891011121314var arr = [1, 2, 1, 2, 3, 3, &apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;b&apos;];Array.prototype.unique = function () &#123; var temp = &#123;&#125;, arr = [], len = this.length; for (var i = 0; i &lt; len; i++) &#123; if (!temp[this[i]]) &#123; temp[this[i]] = &apos;1&apos;; arr.push(this[i]); &#125; &#125; return arr;&#125;","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"小知识","slug":"javascript/语言篇/小知识","date":"2018-08-14T09:10:00.000Z","updated":"2018-08-15T06:56:29.402Z","comments":true,"path":"2018/08/14/javascript/语言篇/小知识/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/小知识/","excerpt":"","text":"数字的toString123456789123.toString()//这个是报错的，因为.的优先级最高，系统会识别成浮点型//要写成这样var num = 123;num.toString();//或者Object.prototype.toString.call(123) js浮点型的精度bug可正常计算的范围，小数点前16位，后16位。 1console.log(0.14 * 100); 12output:14.000000000000002 这个是js的bug，所以后续避免直接使用float进行操作 Math.round() 四舍五入，负数0.5不会+1Math.ceil() 向上取整Math.floor() 向下取整 123456for (var i = 0; i &lt; 10; i++) &#123; 如果是直接Math.random().toFixed(2) * 100，就会出现浮点型精度错误的问题 var num = Math.ceil(Math.random().toFixed(2) * 100); //var num = Math.ceil(Math.random() * 100); console.log(num);&#125; 获取对象上所有的自有键12var a = &#123;a: &apos;b&apos;, c: &apos;d&apos;&#125;;console.log(Object.keys(a)); 12output:[&apos;a&apos;, &apos;c&apos;] delete一旦经历过var的操作，所得出的属性，这种属性叫做不可配置的属性，是delete不掉的。 12345678910111213var num = 123;delete num; // false, 删除不掉delete window.num; // false, 删除不掉var obj = &#123; num: 123;&#125;delete obj.num; // true, 删除掉delete obj; // false, 删除不掉window.num = 123;delete window.num; // true, 删除掉 es3.0和es5.0现在浏览器基本都是基于es3.0的方法加上es5.0的新增方法使用的 es3.0和es5.0产生冲突的部分 es5.0严格模式，那么es3.0和es5.0产生冲突的部分就是用es5.0，否则用es3.0的方法 1&apos;use strict&apos;; 不支持with, arguments, callee, func, caller, 变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined)赋值什么就是什么)，拒绝重复属性和参数","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"基础","slug":"javascript/语言篇/回顾基础","date":"2018-08-14T08:01:00.000Z","updated":"2018-08-15T06:56:04.801Z","comments":true,"path":"2018/08/14/javascript/语言篇/回顾基础/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/回顾基础/","excerpt":"","text":"严格模式 ‘use strict’ECMAScript 5 引入严格模式(‘strict mode’)概念。通过严格模式，在函数内部选择进行较为严格的全局或局部的错误条件检测，使用严格模式的好处是可以提早知道代码中的存在的错误，及时捕获一些可能导致编程错误的ECMAScript行为。在开发中使用严格模式能帮助我们早发现错误。 将’use strict’放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。 1&apos;use struct&apos;; 声明并输出12345678910var MYAPP = &#123;&#125;;var a = &apos;Hello World!&apos;;console.log(a);var arr = [&apos;小明&apos;, &apos;小红&apos;, &apos;小白&apos;, &apos;小鬼&apos;];console.log(&apos;欢迎&apos; + arr.slice(0, 2).join(&apos;,&apos;) + &apos;和&apos; + arr[arr.length - 1] + &apos;同学&apos;);var person = &#123; name: &apos;小明&apos;&#125;; 判断一个属性是否是本身所拥有，而不是继承的1person.hasOwnProperty(&apos;name&apos;) Array的循环由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引 for … in对Array的循环得到的是String而不是Number。 for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 1234567891011var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.name = &apos;Johnny&apos;;for (var i in a) &#123; console.log(i + &apos;(&apos; + typeof i + &apos;) = &apos; + a[i]);&#125;output:0(string) = a1(string) = b2(string) = cname(string) = Johnny 使用for … of循环遍历集合，它只循环集合本身的元素 12345678910var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.name = &apos;Johnny&apos;;for (var i of a) &#123; console.log(i + &apos;(&apos; + typeof i + &apos;)&apos;);&#125;output:a(string)b(string)c(string) 使用forEach()进行遍历 12345678910var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];a.name = &apos;Johnny&apos;;a.forEach(function (value, index, array) &#123; console.log(value + &apos;,&apos; + index + &apos;,&apos; + array);&#125;)output:a,0,a,b,cb,1,a,b,cc,2,a,b,c try catch1try&#123;&#125; catch(e)&#123;&#125; finany&#123;&#125; Error.name的六种值对应的信息： EvalError: eval()的使用与定义不一致 RangeError: 数组越界 ReferenceError: 非法或不能识别的引用数值 SyntaxError: 发生语法解析错误 TypeError: 操作书类型错误 URIError: URI处理函数使用不当 12345678910111213141516171819202122232425262728function abs(x) &#123; if (typeof x !== &apos;number&apos;) &#123; throw &apos;Not a number&apos;; &#125; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;try &#123; console.log(abs(&quot;11&quot;));&#125; catch (error) &#123; console.log(error);&#125;output:Not a numbertry &#123; console.log(abs(11));&#125; catch (error) &#123; console.log(error);&#125;output:11 == 和 === 区别简单来说： == 代表相同， === 代表严格相同 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false。 双等号 == 1234567(1) 如果两个值类型相同，再进行三个等号(===)的比较(2) 如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较： 1) 如果一个是null，一个是undefined，那么相等 2) 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较 (3) 如果是对象相比，要地址相同才相等，所以 &#123;&#125; == &#123;&#125;，一定为false 三等号 === 1234567891011(1) 如果类型不同，就一定不相等(2) 如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( )来判断）(3) 如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。(4) 如果两个值都是true，或是false，那么相等(5) 如果两个值都引用同一个对象或是函数，那么相等，否则不相等(6) 如果两个值都是null，或是undefined，那么相等","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"类数组","slug":"javascript/语言篇/类数组","date":"2018-08-14T06:42:00.000Z","updated":"2018-08-15T06:56:16.074Z","comments":true,"path":"2018/08/14/javascript/语言篇/类数组/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/类数组/","excerpt":"","text":"定义 可以利用属性名模拟数组的特性 可以动态的增长length属性 如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充。 类数组生成的必要条件： 属性要为索引(数字)属性，必须有length属性，最好加上push 123456var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2, push: Array.prototype.push,&#125;","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"数组","slug":"javascript/语言篇/数组","date":"2018-08-14T06:33:00.000Z","updated":"2018-08-15T06:56:23.418Z","comments":true,"path":"2018/08/14/javascript/语言篇/数组/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/数组/","excerpt":"","text":"数组的定义new Array(length/content); 字面量 [] 数组的读和写arr[num] //不可以溢出读，但是不报错，输出undefined arr[num] = xxx //不可以溢出写 数组的方法下面的方法都是es3.0的方法 改变原数组push: 在数组后面加一个值或者一串值 12345678910111213141516171819var arr = [1, 2];arr.push(3);console.log(arr);arr.push(4, 5, 6);console.log(arr);output:[1, 2, 3][1, 2, 3, 4, 5, 6]//模仿push的方法Array.prototype.push = function () &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; this[this.length] = arguments[i]; &#125; return this.length;&#125; pop: 在数组后面去除一个值 123456var arr = [1, 2, 3];arr.pop();console.log(arr);output:[1, 2] shift: 跟pop的相反，在数组前面去除一个值 123456var arr = [1, 2, 3];arr.shift();console.log(arr);output:[2, 3] unshift: 跟push的相反，在数组前面加一个值或者一串值 12345678910var arr = [3, 4];arr.unshift(2);console.log(arr);arr.unshift(0, 1);console.log(arr);output:[2, 3, 4][0, 1, 2, 3, 4] sort: 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 123456789101112var arr = [3, 5, 1, 2, 10, 9, 7];arr.sort();console.log(arr);var arr1 = [3, 5, 1, 2, 10, 9, 7];arr1.sort(function(a, b) &#123; return a - b; &#125;);output:[1, 10, 2, 3, 5, 7, 9] //不传参数就是按照字符编码排序的[1, 2, 3, 5, 7, 9, 10] reverse: 123456var arr = [1, 2, 3];arr.reverse();console.log(arr);output:[3, 2, 1] splice: splice(从第几位开始， 截取多少的长度， 在切口处添加新的数据); 123456789101112131415161718192021var arr = [1, 1, 2, 2, 3, 3];arr.splice(1, 2);console.log(arr);var arr1 = [1, 1, 2, 2, 3, 3];arr1.splice(1, 1, 0, 0, 0);console.log(arr1);var arr2 = [1, 2, 3, 5];arr2.splice(3, 0, 4);console.log(arr2);var arr3 = [1, 2, 3, 4];arr3.splice(-1, 1);console.log(arr3);output:[1, 2, 3, 3][1, 0, 0, 0, 2, 2, 3, 3][1, 2, 3, 4, 5][1, 2, 3] 不改变原数组concat: 1234567var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];var arr = arr1.concat(arr2);console.log(arr);output:[1, 2, 3, 4, 5, 6] join 参数是字符串，不传是按’,’来拼接 12345var arr = [1, 2, 3, 4, 5];console.log(arr.join(&apos;-&apos;));output:1-2-3-4-5 split 12345var string = &quot;1-2-3-4-5&quot;;console.log(string.split(&apos;-&apos;));output:[1, 2, 3, 4, 5] toString 12345var arr = [1, 2, 3, 4];console.log(arr.toString());output:1,2,3,4,5,6 slice 截取，从第几位截取到第几位 123456789var arr = [1, 2, 3, 4, 5];console.log(arr.slice(1, 2));console.log(arr.slice(2));console.log(arr.slice(-2));output:[2][3, 4, 5][4, 5]","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"拷贝","slug":"javascript/语言篇/拷贝","date":"2018-08-14T06:23:00.000Z","updated":"2018-08-15T06:56:13.015Z","comments":true,"path":"2018/08/14/javascript/语言篇/拷贝/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/拷贝/","excerpt":"","text":"浅拷贝12345678910111213141516var obj = &#123; name: &apos;abc&apos;, age: 123, sex: &apos;female&apos;&#125;function clone(origin, target) &#123; var target = target || &#123;&#125;; for (var prop in origin) &#123; if (origin.hasOwnProperty(prop)) &#123; target[prop] = origin[prop]; &#125; &#125; return target;&#125; 这样拷贝完的对象里面的引用值会沿用样板对象里面的引用值。 深拷贝 遍历对象 判断是不是原始值 typeof() toString 判断是数组还是对象 建立对象的数组或对象 递归 123456789101112131415161718192021222324252627282930313233var obj = &#123; name: &apos;abc&apos;, age: 123, sex: &apos;female&apos;, card: [&apos;visa&apos;, &apos;unionpay&apos;], wife: &#123; name: &apos;ssss&apos;, card: [&apos;visa&apos;] &#125;, son: null&#125;var obj1 = &#123;&#125;;function deepClone(origin, target) &#123; var target = target || &#123;&#125;, toStr = Object.prototype.toString, arrStr = &apos;[object Array]&apos;; for (var prop in origin) &#123; if (origin.hasOwnProperty(prop)) &#123; if (origin[prop] != null &amp;&amp; typeof(origin[prop]) == &apos;object&apos;) &#123; target[prop] = toStr.call(origin[prop]) == arrStr ? [] : &#123;&#125;; deepClone(origin[prop], target[prop]); &#125; else &#123; target[prop] = origin[prop]; &#125; &#125; &#125; return target;&#125;deepClone(obj, obj1);","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"继承模式","slug":"javascript/语言篇/继承模式","date":"2018-08-14T06:20:00.000Z","updated":"2018-08-15T06:56:09.924Z","comments":true,"path":"2018/08/14/javascript/语言篇/继承模式/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/继承模式/","excerpt":"","text":"传统形式 –&gt; 原型链过多的继承了没用的属性 12345678910111213141516Grand.prototype.lastName = &apos;Lin&apos;;function Grand() &#123;&#125;var grand = new Grand();Father.prototype = grand;function Father() &#123; this.name = &apos;Johnny&apos;&#125;var father = new Father();Son.prototype = father;function Son() &#123; this.old = 2&#125;var son = new Son(); 借用构造函数 不能继承借用的构造函数的原型 每次构造函数都要多走一个函数 12345678910111213function Person(name, age, sex) &#123; this.name = &apos;Lin &apos; + name; this.age = age; this.sex = sex;&#125;function Student(name, age, sex, tel, grade) &#123; Person.call(this, name, age, sex); this.tel = tel; this.grade = grade;&#125;var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017); 共享原型不能随意改动自己的原型 123456789101112131415161718192021Father.prototype.lastName = &apos;Lin&apos;;function Father() &#123;&#125;function Son() &#123;&#125;function inherit(Target, Origin) &#123; Target.prototype = Origin.prototype;&#125;inherit(Son, Father);不足：Son.prototype.sex = &apos;male&apos;;var son = new Son();var father = new Father();console.log(son.sex);console.log(father.sex); 123output:malemale 圣杯模式123456789101112131415161718192021222324function inherit(Target, Origin) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constuctor = Target; Target.prototype.uber = Origin.prototype;&#125;Father.prototype.lastName = &apos;Lin&apos;;function Father() &#123;&#125;function Son() &#123;&#125;inherit(Son, Father);Son.prototype.sex = &apos;male&apos;;var son = new Son();var father = new Father();console.log(son.sex);console.log(father.sex); 123output:maleundefined 更加高端的写法 1234567891011var inherit = (function() &#123; var F = function() &#123;&#125;; return function(Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constuctor = Target; Target.prototype.uber = Origin.prototype; &#125;&#125;)();利用闭包实现变量私有化，F存在闭包里面","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"对象枚举","slug":"javascript/语言篇/对象枚举","date":"2018-08-14T06:16:00.000Z","updated":"2018-08-15T06:55:58.723Z","comments":true,"path":"2018/08/14/javascript/语言篇/对象枚举/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/对象枚举/","excerpt":"","text":"for…in会返回原型的自己设置的属性 1234567891011var obj = &#123; name: &apos;123&apos;, age: 123, sex: &apos;male&apos;, height: 180, width: 100&#125;for (var prop in obj) &#123; console.log(prop + &quot; &quot; + typeof(prop) + &quot; &quot; + obj[prop]);&#125; 123456output:name string 123age string 123sex string maleheight string 180width string 100 hasOwnProperty返回一个布尔值，判断对象是否包含特定的自身（非继承）属性 12345678910111213141516var obj = &#123; name: &apos;123&apos;, age: 123, sex: &apos;male&apos;, height: 180, width: 100, __proto__: &#123; lastName: &apos;li&apos; &#125;&#125;for (var prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; console.log(prop + &quot; &quot; + typeof(prop) + &quot; &quot; + obj[prop]); &#125;&#125; 123456output:name string 123age string 123sex string maleheight string 180width string 100 instanceof用来在运行时指出对象是否是特定类的一个实例。 A对象是不是B构造函数构造出来的 看A对象的原型链上有没有B的原型 123456789function Person() &#123; &#125;var person = new Person();console.log(person instanceof Person);console.log(person instanceof Object);console.log(person instanceof Array); 1234output:truetruefalse","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"命名空间","slug":"javascript/语言篇/命名空间","date":"2018-08-14T06:15:00.000Z","updated":"2018-08-15T06:56:18.911Z","comments":true,"path":"2018/08/14/javascript/语言篇/命名空间/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/命名空间/","excerpt":"","text":"利用闭包来实现命名空间，模块化开发 12345678910111213141516171819202122232425262728var adName = &apos;none&apos;;var initTopAD = (function initTopAD() &#123; var adName = &apos;top&apos;; var addAD = function() &#123; console.log(&apos;add &apos; + adName); &#125; return function() &#123; addAD(); &#125;&#125;());var initBottomAD = (function () &#123; var adName = &apos;bottom&apos;; var addAD = function() &#123; console.log(&apos;add &apos; + adName); &#125; return function() &#123; addAD(); &#125;&#125;());initTopAD();initBottomAD();console.log(adName); 1234output:add topadd bottomnone","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"this","slug":"javascript/语言篇/this","date":"2018-08-14T06:11:00.000Z","updated":"2018-08-15T06:56:35.525Z","comments":true,"path":"2018/08/14/javascript/语言篇/this/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/this/","excerpt":"","text":"函数预编译过程 this -&gt; window12345678910111213141516function test(c) &#123; var a = 123; function b() &#123;&#125;&#125;test(1);/*预编译产生AOAO &#123; arguments: [1], this: window, c: 1, a: undefines, b: function() &#123;&#125;&#125;*/ 1234567891011121314151617function test(c) &#123; // var this = Object.create(test.prototype); var a = 123; function b() &#123;&#125;&#125;new test(1);/*预编译产生AOAO &#123; arguments: [1], this: obj, c: 1, a: undefines, b: function() &#123;&#125;&#125;*/ 全局作用域里 this -&gt; windowcall/apply 可以改变函数运行时this指向obj.func(); func()里面的this指向obj1234567var obj = &#123; show: function() &#123; console.log(this.name); &#125;, name: &apos;abc&apos;&#125;obj.show() 谁调用show，里面的this就指向谁","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"原型链","slug":"javascript/语言篇/原型链","date":"2018-08-14T06:07:00.000Z","updated":"2018-08-15T06:56:32.536Z","comments":true,"path":"2018/08/14/javascript/语言篇/原型链/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/原型链/","excerpt":"","text":"原型 prototype定义：原型是function对象的一个属性，它定义了构造函数制造的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 利用原型特点和概念，可以提取公有属性 对象如何查找原型 -&gt; 隐式属性 __proto__ 对象如何查找对象的构造函数 -&gt; constructor 函数默认就会自动生成prototype这个空对象。 12345678910111213//或者可以写Person.prototype.lastName = &apos;Lin&apos;;Person.prototype = &#123; lastName: &apos;Lin&apos;&#125;function Person(name) &#123; this.name = name; this.show = function () &#123; console.log(this.lastName + &apos; &apos; + this.name); &#125;&#125;var person = new Person(&apos;Johnnny&apos;);person.log(); 12output:Lin Johnny 12345678910111213141516171819202122Person.prototype.name = &apos;abc&apos;;function Person() &#123;//这里会隐性调用 var this = &#123; __proto__: Person.prototype &#125;&#125;var person = new Person();console.log(person.__proto__.name);console.log(person.name);Person.prototype.name = &apos;ccc&apos;;console.log(person.__proto__.name);console.log(person.name);var obj = &#123; name: &apos;sunny&apos;&#125;//可以更改__proto__，让它指向其他原型person.__proto__ = obj;console.log(person.__proto__.name);console.log(person.name); 1234567output:abcabcccccccsunnysunny 1234567891011121314151617181920212223Person.prototype.name = &apos;abc&apos;;function Person() &#123; //这里会隐性调用 var this = &#123; __proto__: Person.prototype &#125;&#125;var person = new Person();console.log(person.__proto__.name);console.log(person.name);//解释为Person.prototype更换了一个新的对象，但是原来的Person.__proto__的指向还是原来的对象//Person.prototype = &#123;name: &apos;a&apos;&#125;;//__proto__ = Person.prototype;//Person.prototype = &#123;name: &apos;b&apos;&#125;;Person.prototype = &#123; name: &apos;sunny&apos;&#125;var person1 = new Person();console.log(person1.__proto__.name);console.log(person1.name); 12345output:abcabcsunnysunny 原型链如何构成原型链 12345678910111213141516Grand.prototype.lastName = &apos;Lin&apos;;function Grand() &#123;&#125;var grand = new Grand();Father.prototype = grand;function Father() &#123; this.name = &apos;Johnny&apos;&#125;var father = new Father();Son.prototype = father;function Son() &#123; this.old = 2&#125;var son = new Son(); 特殊的修改 1234567891011121314151617181920212223242526272829Grand.prototype.lastName = &apos;Lin&apos;;function Grand() &#123;&#125;var grand = new Grand();Father.prototype = grand;function Father() &#123; this.name = &apos;Johnny&apos;, this.forturn = &#123; &apos;card1&apos;: &apos;Visa&apos; &#125;&#125;var father = new Father();Son.prototype = father;function Son() &#123; this.old = 2&#125;var son = new Son();console.log(son.forturn);//这个修改是直接获取引用值进行修改son.forturn.card2 = &apos;UnionPay&apos;;console.log(son.forturn);//这个修改是直接从新赋值son.forturn = &apos;200&apos;;console.log(son.forturn); 1234output:&#123;&apos;card1&apos;: &apos;Visa&apos;&#125;&#123;&apos;card1&apos;: &apos;Visa&apos;, &apos;card2&apos;: &apos;UnionPay&apos;&#125;200 Test 123456789101112131415Person.prototype = &#123; name: &apos;a&apos;, sayName: function() &#123; console.log(this.name); &#125;&#125;function Person() &#123; this.name = &apos;b&apos;;&#125;var person = new Person();//谁调用sayName这个方法，里面的this就指向谁console.log(person.sayName());console.log(Person.prototype.sayName()); 123output:ba 绝大多数对象的最终都会继承自Object.prototype 12345var obj = &#123;&#125;; // --&gt; new Object();//相当于 var obj = new Object(); 少用，尽量用字面量//obj.__proto__ == Object.prototypePerson.prototype = &#123;&#125;; //--&gt; Object.prototype 不会继承Object.prototype的对象 12//nullvar obj = Object.create(null); Object.create(原型) 12345678910//var obj = Object.create(原型);var obj = &#123;name: &apos;sunny&apos;, age: 123&#125;;var obj1 = Object.create(obj);console.log(obj1.__proto__);Person.prototype = &#123;name: &apos;sunny&apos;, age: 123&#125;;function Person() &#123;&#125;var person = Object.create(Person.prototype);console.log(person.__proto__); 123output:&#123;name: &apos;sunny&apos;, age: 123&#125;&#123;name: &apos;sunny&apos;, age: 123&#125; call/apply/bind作用，改变this指向。 call/apply区别，后面传的参数形式不同。 call 需要把实参按照形参的个数传进去 apply 需要传一个arguments bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。 call 12345678910111213141516function test() &#123;&#125;test() // ---&gt; test.call();var obj = &#123;&#125;function Person(name, age) &#123; this.name = name; this.age = age;&#125;//Person里面的this已经改变成obj了。Person.call(obj, &apos;cheng&apos;, 300); 1234567891011121314151617function Person(name, age, sex) &#123; this.name = &apos;Lin &apos; + name; this.age = age; this.sex = sex;&#125;function Student(name, age, sex, tel, grade) &#123; //* var this = &#123;&#125;; // 改变this的指向，所以用Person里面的方法去封装this，封装后变成 // var this = &#123;name: &apos;Lin Johnny&apos;, age: 123, sex: &apos;male&apos;&#125;; Person.call(this, name, age, sex); this.tel = tel; this.grade = grade;&#125;var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017); apply 123456789101112131415161718function Person(name, age, sex) &#123; this.name = &apos;Lin &apos; + name; this.age = age; this.sex = sex;&#125;function Student(name, age, sex, tel, grade) &#123; //* var this = &#123;&#125;; // 改变this的指向，所以用Person里面的方法去封装this，封装后变成 // var this = &#123;name: &apos;Lin Johnny&apos;, age: 123, sex: &apos;male&apos;&#125;; //跟call的区别就是参数不同，apply除了指向，其余参数都包含在数组里面 Person.apply(this, [name, age, sex]); this.tel = tel; this.grade = grade;&#125;var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017); bind bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 12345678910var bar = function() &#123; console.log(this.x); &#125;var foo=&#123; x:3 &#125; var func = bar.bind(foo);func(); 12output:3","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"函数","slug":"javascript/语言篇/函数","date":"2018-08-14T06:05:00.000Z","updated":"2018-08-15T06:56:01.502Z","comments":true,"path":"2018/08/14/javascript/语言篇/函数/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/函数/","excerpt":"","text":"匿名函数123456789var abs = function(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;console.log(abs(10)); 这种形式看起来好像是常规的变量赋值语句。但是函数表达式和函数声明的区别在于，函数表达式在使用前必须先赋值。 12345678910111213141516171819console.log(abs(10));function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;一般定义函数不会出错console.log(abs(10));var abs = function(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;报错，显示undefined is not a function 造成这种现象是因为解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它的所在的的代码行，才会真正的被解析。 函数表达式中，创建的函数叫做匿名函数，因为function关键字后面没有标识符。 立即执行函数12345(function() &#123; var a = 123; var b = 456; console.log(a + b);&#125;()) 两种立即执行函数: 12(function()&#123;&#125;()); W3C 建议第一种(function()&#123;&#125;)(); 只有表达式才能被执行符号执行, 把函数放在()里面就会被转成表达式 123function () &#123;&#125;这不是表达式，这是函数 函数能够被立即执行，执行完后函数被放弃，test不再代表函数，能被符号执行的函数，就会变成立即执行函数。 123var test = function () &#123; console.log(&apos;a&apos;);&#125;(); 有正负和叹号或者或与在前面自动变成表达式，所以可以立即执行，然后忽略函数名。 1234567891011121314151617181920212223(function(test)&#123; console.log(test); //输出123，使用()运算符&#125;(123));(function(test)&#123; console.log(test); //输出123，使用()运算符&#125;)(123);!function(test)&#123; console.log(test); //输出123，使用!运算符&#125;(123);+function(test)&#123; console.log(test); //输出123，使用+运算符&#125;(123);-function(test)&#123; console.log(test); //输出123，使用-运算符&#125;(123);var fn = function(test)&#123; console.log(test); //输出123，使用=运算符&#125;(123); 12345function test(a, b, c, d) &#123; console.log(a + b + c + d);&#125;(1, 2, 3, 4);这个不报错，系统把它分成了函数和后面参数，test现在变成了函数。如果括号里面不加东西，那么就会报错。 使用立即执行函数的好处： 1通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可，如jQuery代码结构。 闭包实现公有变量12345678910111213141516eg: 函数累加器function add() &#123; var num = 0; function a() &#123; num++; console.log(num); &#125; return a;&#125;函数a保留着函数add的AOvar myAdd = add();myAdd(); 1myAdd(); 2myAdd(); 3 可以做缓存（存储结构）1234567891011121314151617181920212223function test() &#123; var food = &apos;apple&apos;; var obj = &#123; eatFood: function() &#123; if (food != &apos;&apos;) &#123; console.log(&apos;eating &apos; + food); food = &quot;&quot;; &#125; else &#123; console.log(&apos;nothing&apos;); &#125; &#125;, pushFood: function(myFood) &#123; food = myFood; &#125; &#125; return obj;&#125;var a = test();a.edtFood(); eating applea.edtFood(); notinga.pushFood(&apos;banana&apos;); a.edtFood(); eating banana 可以实现封装，属性私有化1234567891011121314151617181920212223242526272829function Person(name, money) &#123; var lunch = 15; this.name = name; this.money = money; this.eat = function() &#123; this.money = this.money - lunch; &#125; this.buffet = function() &#123; lunch = 15; &#125; this.mee = function() &#123; lunch = 12; &#125; this.getLunch = function() &#123; console.log(lunch); &#125;&#125;var person = new Person(&apos;Johnny&apos;, 100);person.buffet();person.getLunch();person.eat();person.mee();person.getLunch(); 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Block&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; padding: 0; margin: 0; &#125; ul &#123; list-style: none; &#125; li:nth-of-type(2n) &#123; background-color: red; &#125; li:nth-of-type(2n + 1) &#123; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; var liCollection = document.getElementsByTagName(&apos;li&apos;); for (var i = 0; i &lt; liCollection.length; i++) &#123; //闭包的应用 (function (k) &#123; liCollection[k].addEventListener(&quot;click&quot;, function () &#123; console.log(k); &#125;); &#125;(i)) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"对象、包装类","slug":"javascript/语言篇/对象、包装类","date":"2018-08-14T06:03:00.000Z","updated":"2018-08-15T06:55:56.723Z","comments":true,"path":"2018/08/14/javascript/语言篇/对象、包装类/","link":"","permalink":"http://yoursite.com/2018/08/14/javascript/语言篇/对象、包装类/","excerpt":"","text":"声明对象12345678910var person = &#123; name: &apos;Johnny&apos;, old: 25, nextYear: function() &#123; this.old = this.old + 1; &#125;, lastYear: function() &#123; this.old = this.old - 1; &#125;&#125;; 删除属性 1delete person.old; 对象的创建方法123456789101112131415161718192021221、plainObject 对象字面量/对象直接量var obj = &#123;&#125;2、构造函数 2.1、系统自带的构造函数 Object() Array() var obj = new Object(); 2.2、自定义 function Car(color) &#123; //里面会隐性调用，可以选择不写，用*来标识 //* var this = &#123; //* __proto__: Car.prototype //* &#125;; this.name = &apos;BMW&apos;; this.wheel = 4; this.color = color; //* return this; //如果手动return其他值，除非是对象，否则都会自动变成this，比如： //return [1, 2, 3]; output: [1, 2, 3] //return 1; output: Car &#123;name: &apos;BMW&apos;, ...&#125; &#125; var car = new Car(&apos;red&apos;); 12345678var num = new Number(123); output: Number&#123;123&#125;num.abc = &apos;123&apos;; output: Number&#123;123, abc: &apos;123&apos;&#125;num + 10; output: 133 返回一个整型值var bol = new Boolean(&apos;true&apos;); output: Boolean&#123;[[PrimitiveValue]]: true&#125;undefined和null不能设置属性 包装类1234567var num = 4;num.len = 3; -&gt; 隐性调用 new Number(4).len = 3; 然后再调用deleteconsole.log(num.len); -&gt; 隐性调用 new Number(4).len; 然后再输出output: undefined 123456789101112131415161718192021222324Test:var arr = [1, 2, 3, 4, 5];arr.length = 2;console.log(arr); output: [1, 2]var str = &apos;abcd&apos;;str.length = 2;-&gt; 因为str是基础类型，直接给它的属性赋值会隐性调用 new String(&apos;abcd&apos;).len = 2; 然后再调用deleteconsole.log(str); output: abcdvar str = &apos;abc&apos;;str += 1; //str == &apos;abc1&apos;;var test = typeof str;if (test.length == 6) &#123; -&gt; 因为str是基础类型，直接给它的属性赋值会隐性调用 new String(&apos;abc1&apos;).sign = &apos;typeof的返回结果可能为String&apos;; 然后再调用delete test.sign = &apos;typeof的返回结果可能为String&apos;;&#125; -&gt; test.sign会隐性调用 new String(test).sign，然后输出test.signconsole.log(test.sign). output: undefined","categories":[{"name":"javascript随记","slug":"javascript随记","permalink":"http://yoursite.com/categories/javascript随记/"}],"tags":[]},{"title":"在MRC下的内存管理","slug":"objective-c/在MRC下的内存管理","date":"2018-08-14T05:46:00.000Z","updated":"2018-08-14T14:25:26.610Z","comments":true,"path":"2018/08/14/objective-c/在MRC下的内存管理/","link":"","permalink":"http://yoursite.com/2018/08/14/objective-c/在MRC下的内存管理/","excerpt":"","text":"以下的解释全部都在MRC环境下 自己持有的对象，自己所持有。 非自己生成的对象，自己也能持有。 不再需要自己持有的对象时，应该要释放。 非自己持有的对象无法释放。 对象操作与Objective-C方法的对应 对象操作 Objective-C 方法 生成并持有对象 alloc/new/copy/mutableCopy 等方法 持有对象 retain 方法 释放对象 release 方法 废弃对象 dealloc 方法 自己生成的对象，自己所持有123456// 自己生成并持有对象id obj = [[NSObject alloc] init];id obj = [NSObject new];// 自己持有对象 copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本。与copy方法类似，mutableCopy方法利用基于NSMutableCopying方法约定，由各类实现的mutableCopyWithZone:方法生成并持有对象的副本。两者的区别在于copy方法生成不可变更的对象，而mutableCopy方法生成可变更的对象。虽然是对象的副本，但同alloc、new方法一样，在“自己生成并持有对象”这点上没有改变。 非自己生成的对象，自己也能持有1234567// 取得非自己生成并持有的对象id obj = [NSMutableArray array];// 取得的对象存在，但自己不持有对象[obj retain];// 调用retain，自己持有对象 通过retain方法，非自己生成的对象跟用alloc/new/copy/mutableCopy方法生成并持有的对象一样，成为了自己所持有的 不再需要自己持有的对象时释放自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用release方法。 123456789101112131415161718192021222324252627// 自己生成并持有对象id obj = [[NSObject alloc] init];// 自己持有对象[obj release];/*释放对象指向对象的指针仍然被保留在变量obj中，貌似能够访问。但对象一经释放绝对不可访问。*/// 取得非自己生成并持有的对象id obj = [NSMutableArray array];// 取得的对象存在，但自己不持有对象[obj retain];// 调用retain，自己持有对象[obj release];/*释放对象对象不可再被访问*/ 用alloc/new/copy/mutableCopy方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。 如果要用某个方法生成对象，并将其返回该方法的调用方，那么它的源代码是这样的 12345678910111213141516171819202122- (id)allocObject &#123; //自己生成并持有对象 id obj = [[NSObject alloc] init]; //自己持有对象 return obj;&#125;/*如上所示，原封不动地返回用alloc方法生成并持有的对象，就能让调用方也持有该对象。*/// 取得非自己生成并持有的对象id obj = [self allocObject];//自己持有对象[obj release];/*释放对象对象不可再被访问*/ 那么，调用[NSMutableArray array]方法使取得的对象存在，但自己不持有对象，又是如何实现的呢？ 123456789101112131415161718192021- (id)object &#123; //自己生成并持有对象 id obj = [[NSObject alloc] init]; [obj autorelease]; //取得的对象存在，但自己不持有对象 return obj;&#125;// 取得非自己生成的对象，但自己不持有对象id obj = [self object];// 自己持有对象[obj retain];[obj release];/*释放对象对象不可再被访问*/ 我们使用autorelease方法。用该方法，可以使取得的对象存在，单自己不持有对象。autorelease提供这样的功能，使对象在超出指定的生存范围时能够自动并正确的释放(调用release方法)。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"提高调用Objective-C方法的速度","slug":"objective-c/提高调用Objective-C方法的速度","date":"2018-08-14T05:21:00.000Z","updated":"2018-08-14T14:24:03.652Z","comments":true,"path":"2018/08/14/objective-c/提高调用Objective-C方法的速度/","link":"","permalink":"http://yoursite.com/2018/08/14/objective-c/提高调用Objective-C方法的速度/","excerpt":"","text":"GNUseto中的autorelease实际上是用一种特殊的方法来实现的。这种方法能够高效地运行OSX, iOS应用程序中频繁调用autorelease方法，它被称为”IMP Caching”。 在进行调用时，为了解决类名/方法名以及取得方法运行时的函数指针，要在框架初始化时对其结果值进行换缓存。 12345678id autorelease_class = [NSAutoreleasePool class];SEL autorelease_sel = @selector(addObject:);IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];//实际调用就是使用缓存的结果值。- (id)autorelease &#123; (*autorelease_imp)(autorelease_class, autorelease_sel, self);&#125; 这就是IMP Caching的方法调用。虽然同一下源代码完全相同，但从运行效率上看，即使它依赖于运行环境，一般而言速度也是其他方法的2倍。 123- (id)autorelease &#123; [NSAutorelesePool addObject:self];&#125;","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"深拷贝和浅拷贝","slug":"objective-c/深拷贝和浅拷贝","date":"2018-08-14T04:12:00.000Z","updated":"2018-08-14T14:23:15.875Z","comments":true,"path":"2018/08/14/objective-c/深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2018/08/14/objective-c/深拷贝和浅拷贝/","excerpt":"","text":"copy和mutablecopy copy: 拷贝出来的对象类型总是不可变类型 (例如: NSString, NSDictionary, NSArray) mutableCopy: 拷贝出来的对象类型总是可变类型 (例如: NSMutableString, NSMutableDictionary, NSMutableArray) 12345678910111213141516NSString *string1 = @&quot;123&quot;;NSString *string2 = [string1 copy];NSString *string3 = [string1 mutableCopy];NSMutableString *string4 = [string1 mutableCopy];NSMutableString *string5 = [string1 copy];output-p string1:(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;output-p string2:(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;output-p string3:(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;output-p string4:(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;output-p string5:(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot; 注意： 在runtime下NSString的”真身”是NSCFConstantString，而NSMutableString的”真身”是NSCFString，然后我们就能很清楚的看到，只要是copy得到的值就是不可变类型，而mutablecopy得到的是可变类型。 NSTaggedPointerString为苹果在64位对NSString和NSNumber等对象的优化 #深拷贝和浅拷贝 imutableObject为不可变对象，如: NSString, NSArray等 mutableObject为可变对象，如: NSMutableString, NSMutableArray等 在imutableObject对象中: 对 immutable 对象进行 copy 操作，是指针复制【浅拷贝】，mutableCopy 操作时内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下： 123456789101112131415161718192021222324252627[immutableObject copy] //浅复制[immutableObject mutableCopy] //深复制[mutableObject copy] //深复制[mutableObject mutableCopy] //深复制NSString *string1 = @&quot;123&quot;;NSString *string2 = [string1 copy];NSMutableString *string3 = [string1 mutableCopy];NSMutableString *string4 = [NSMutableString stringWithFormat:@&quot;123&quot;];NSString *string5 = [string4 copy];NSMutableString *string6 = [string1 mutableCopy];output-p string1:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p string2:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p string3:(__NSCFString *) = 0x000000010041eb10 @&quot;123&quot;output-p string4:(__NSCFString *) = 0x000000010342ceb0 @&quot;123&quot;output-p string5:(NSTaggedPointerString *) = 0x0000000033323135 @&quot;123&quot;output-p string6:(__NSCFString *) = 0x000000010342c830 @&quot;123&quot; 可以看出，除了对immutable的Copy动作得到的string是浅拷贝外，其他的都是深拷贝。 在mutableObject对象中: 对 immutable 对象进行 copy，是指针复制【浅拷贝】， mutableCopy 是内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。 1234567891011121314151617181920212223242526272829303132333435363738394041[immutableObject copy] // 浅复制[immutableObject mutableCopy] //单层深复制[mutableObject copy] //单层深复制[mutableObject mutableCopy] //单层深复制NSString *string1 = @&quot;123&quot;;NSArray *array1 = @[string1];NSArray *array2 = [array1 copy];NSMutableArray *array3 = [array1 mutableCopy]; NSMutableArray *array4 = @[string1];NSArray *array5 = [array4 copy];NSMutableArray *array6 = [array4 mutableCopy];output-p string1:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array1:(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;output-p array1[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array2:(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;output-p array2[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array3:(__NSArrayM *) = 0x00000001004002e0 @&quot;1 element&quot;output-p array3[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array4:(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;output-p array4[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array5:(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;output-p array5[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array6:(__NSArrayM *) = 0x000000010041ec30 @&quot;1 element&quot;output-p array6[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot; 这里说的单层深复制其实就是所谓的不完全深拷贝，这个跟Java中的深拷贝概念又有所区别，iOS中集合对象的“深拷贝”只拷贝了一个壳，对于壳内的元素是浅拷贝，和java中递归的深拷贝有所不同。 property中的copy属性123456789@property (copy, nonatomic) NSString *someString;- (void)setSomeString:(NSString *)someString&#123; //没有写copy属性时 _someString = someString; //写了copy属性时 _someString = [someString copy];&#125; 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。 也就是说，当你加上一个copy属性时，这个对象在被set的时，就不再是改变这个对象的原有内存，而是修改这个对象的不可变副本内存。这样就能够保证这个元素不会被外部修改影响。 1234567891011121314@property(nonatomic, strong) NSArray *array;NSArray *array = @[@1, @2, @3, @4];NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array];self.array = mutableArray;[mutableArray removeAllObject];NSLog(@&quot;%@&quot;, self.array);output:&lt;__NSArrayM 0x60800025a9d0&gt;()这就是property里不用copy而用strong的结果，当你确定这个元素是不可变的，那么copy属性还是很有必要的","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"何为代码质量","slug":"objective-c/何为代码质量","date":"2018-08-14T04:00:00.000Z","updated":"2018-08-14T14:22:33.498Z","comments":true,"path":"2018/08/14/objective-c/何为代码质量/","link":"","permalink":"http://yoursite.com/2018/08/14/objective-c/何为代码质量/","excerpt":"","text":"1、使用 ++i 而不是 i++经常看到这样的代码： 1for (int i = 0;; i++) &#123;&#125; 单步自增 (或自减) 操作，最好是使用++i而不是i++，效率略高。 大家应该都知道++i的返回值是自增过后的，而i++的返回值是自增之前的。其实从这点就可以猜测：++i内部实现应该是直接将 i 这块内存 +1 然后返回，而i++需要使用一个局部变量来存储 i 的值，然后 i 加一，最后返回局部变量的值（别告诉我你能先 return 再执行自增）。 如果某一种语言的i++不能作为左值，那么也可以猜测这个局部变量是用const修饰的。 所以，i++理论上比++i有更多的消耗，代码就这样写吧： 1for (int i = 0;; ++i) &#123;&#125; 2、巧用位运算位运算效率很高，而且有很多巧妙的用法，这里提出一个需求： 123456typedef enum : NSUInteger &#123; TestEnumA = 1, TestEnumB = 1 &lt;&lt; 1, TestEnumC = 1 &lt;&lt; 2, TestEnumD = 1 &lt;&lt; 3&#125; TestEnum; 对于该多选枚举，如何判断该枚举类型的变量是否是复合项？ 如果按照常规的思路，就需要逐项判断是否包含，时间复杂度最差为O(n)。而使用位运算可以这么写： 1234TestEnum test = …;if (test == (test &amp; (-test))) &#123; //不是复合项&#125; 实际上就是通过负数二进制的一个特性来判断，看如下分析便一目了然： 1234test 0000 0100反码 1111 1011补码 1111 1100test &amp; (-test) 0000 0100 3、灵活使用组合运算符不明白有些工程师为什么排斥组合运算符，他们喜欢这么写： 123bool is = …;if (is) a = 1;else a = 2; 使用三目运算符： 12bool is = …;a = is ? 1 : 2; 其他组合运算符比如 ?: %=等，灵活的使用它们可以让代码更加的简洁清晰。 4、const 和 static 和宏static可以让变量进入静态区，提高变量生命周期至程序结束。值得注意的是，文件中最外层（#include下）的变量本身就是在静态区的，而这种情况使用static是为了变量的私有化。 const 修饰的变量在常量区不可变，是在编译阶段处理；宏是在预编译阶段执行宏替换。所以频繁使用 const 不会产生额外的内存，而所有使用宏的地方都可能开辟内存，况且，预编译阶段的大量宏替换会带来一定的时间消耗。 所以笔者的建议是，能用常量的不用宏，比如一个网络请求的 url： 12345// .h 接口文件extern NSString * const BaseServer;// .m 实现文件NSString * const BaseServer = @&quot;https://…&quot;; 值得注意的是，const 是修饰右边内存，所以这里是想要BaseServer字符串指针指向的内容不可变，而不是*BaseServer内容不可变。 5、空间换时间在很多场景中，可以牺牲一定的空间来降低时间复杂度，为了程序的高效运行，工程师可以自行判断是否值得，下面举一个代码例子，判断字符串是否有效： 1234567891011BOOL notEmpty(NSString *str) &#123; if (!str) return NO; static NSSet *emptySet; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; emptySet = [NSSet setWithObjects:@&quot;&quot;, @&quot;(null)&quot;, @&quot;null&quot;, @&quot;&quot;, @&quot;NULL&quot;, nil]; &#125;); if ([emptySet containsObject:str]) return NO; if ([str isKindOfClass:NSNull.class]) return NO; return YES;&#125; 使用一个 hash 来提高匹配效率，这在数据较少时可能体现不出优势，甚至会让效率变低，但是在数据量稍大的时候优势就明显了，而且这样写可以避免大量的if-elseif等判断，逻辑更清晰。 值得注意的是，此处使用static来提升局部变量emptySet的生命周期，而不是将这句代码写在方法体外面。在变量声明时，一定要明确它的使用范围，限定合适的作用域。 6、容器类型的合理选择在 C++ 中，若不需要键值对的 hash ，就使用set而不是map；若不需要排序的集合就使用unordered_set而不是sest。 归根结底也是对时间复杂度的考虑，选择容器类型时，一定要选择“刚好”能满足需求的，能用更“简单”效率更高的容器就不用“复杂”效率更低的容器。 7、初始化不要交给编译器对于变量的使用，尽量在类或结构体初始化方法中对其赋初值，而不要依赖于编译器。因为在可见的未来，不管是编译器的更新或是代码跨平台移植，这些变量的初始值都不会受编译器影响。 8、多分支结构处理这是一个老生常谈的东西了，多分支结构尽量使用 switch 而不是大量的 if - else if 语句，若非要用 if - else if 来写，则出现频率高的分支优先判断，可以从整体上最大限度的减少判断次数。 不要小看这些少量的效率提升，放大到整个项目也是有不小的收益。 9、避免数据同步经常会有一些需求，对一系列的数据有很多额外的操作，比如选择、删除、筛选、搜索等。代码设计时，要尽量将所有的操作状态都缓存到同一个数据模型中，而不是使用多个容器数据结构来处理，我们应该尽量避免数据同步防止出错。 10、合理使用局部指针经常会看到这种代码： 123doSomething(city.school.class.jack.name, city.school.class.jack.age, city.school.class.jack.sex); 当同一个变量的调用过深且使用频繁时，可以使用一个局部指针来处理： 1234Person *jack = city.school.class.jack;doSomething(jack.name, jack.age, jack.sex); 相对于指针变量所占用的空间来说，代码的简洁和美观度稍显重要一点。 11、避免滥用单例单例作为一种设计模式应用非常广泛，在移动端开发中，有些开发者利用它来实现非缓存传值，笔者认为这是一个错误的做法，使用单例传值的时候你需要管理单例中的数据何时释放与更新，可能会引发数据错乱。 单例存在的意义应该是缓存数据，而非传值，切勿为了方便滥用单例。 12、避免滥用继承继承本身和解耦思想有些冲突，代码设计中要尽量避免过深的继承关系，因为子类与父类的耦合将无法真正剥离。过深的继承关系会增加调试的困难程度，并且若继承关系设计有缺陷，修改越深的类影响面将会越广，可能带来灾难性的后果。 可以使用分类的方式做一些通用配置，然后在具体类中简洁的调用一次方法；也可以使用 AOP 思想，hook 住生命周期方法无侵入配置（比如埋点）。 比如 iOS 开发中，可能会有开发者喜欢写一套基类，实际上只是基于系统的类做了小量的配置，比如BaseViewController、BaseView、BaseModel、BaseViewModel，甚至是BaseTableViewCell。控制器基类可以对栈和导航栏做一些配置，还是有一点使用意义，至于其它的笔者感觉就是过度设计，其实很大意义上BaseViewController也没有存在的必要。 记住：过多的基类并不是代码规范，那是你囚禁其他开发者的牢笼。 13、避免过度封装提取方法的原则是功能单一性，但若功能本身就是很少的一两句代码可能就没必要额外提取了。在保证代码清晰的情况下，很多时候提取逻辑也是需要酌情考虑的。 有见过开发者使用一套所谓的简洁配置 UI 的框架，不过就是将 UI 控件的属性封装成链式语法之类的，用起来有种快一些的错觉，殊不知这就是过度封装的典范。 封装的意义在于简洁的解决一类问题，而非少敲那几个字母，过度封装只会增加其他开发者阅读你代码的成本。 比如业界知名的 Masonry，使用它时比原生的 layout 快了不止 10 倍，而且代码很简洁易懂，极大的提高了开发效率。 14、避免过多代码块嵌套比如代码中大量的 if - else 嵌套判断，大量的嵌套循环，大量的闭包嵌套。 出现这种情况首先要考虑的是分支结构处理是否多余？循环是否可以优化时间复杂度？当排除这些可优化项过后，可以做一些方法提取减少大量的代码块嵌套，方便阅读。 15、时刻注意空值和越界写某块代码中，要时刻注意空值和越界的处理，比如给NSDictionary插入空值会崩溃，从NSArray越界取值会崩溃，这些情况要时刻考虑到。 当然，可能有人会说有方法可以全局避免崩溃。实际上笔者不是很赞同这种做法，这可能会让新手开发者永远发现不了自己代码的漏洞。 16、时刻注意代码的调用时机和频率当你写一块代码时，需要习惯性的思考两个问题：这块代码的共有变量会被多线程访问从而存在安全问题么？这块代码可能会在一个 RunLoop 循环中调用很频繁么？ 对于第一个问题，可能需要使用“锁”来保证线程安全，而锁的选择有一些技巧，比如整形使用原子自增保证线程安全：OSAtomicIncrement32()；调用耗时短的代码使用dispatch_semaphore_t更高效；可能存在重复获取锁时使用递归锁处理… 对于第二个问题，只需要在合适的地方加入自动释放池 (autoreleasepool) 避免内存峰值就行了。 17、减少界面代码复用、增加功能代码的复用对于大前端来说，界面是项目中重要的组成部分，而有时候设计师给的图中，不同界面有很多相同的元素，看起来一模一样，所以很多工程师偷懒直接复用界面了。 在这里，笔者建议尽量少的复用界面，宁愿选择复制一份。 试想，目前版本两个界面相同，你复用了它，当下个版本其中一个界面要调整一下，这时你继续偷懒，加入一些判断来区分逻辑，下一次迭代又增加了差异，你又偷懒加入判断逻辑…… 最终你会发现，这个界面里面已经逻辑爆炸了，拆分成两个界面将变得异常困难。 而对于功能代码，笔者是提倡多提取，多复用，切记命名规范和适当的注释。 18、组件的设计技巧在封装一些小组件时，一定要形成习惯，不想暴露给使用者的属性和方法不要写在接口文件中，甚至于某些延续父类的方法不想使用者使用，可以如下处理： 1(instancetype)init UNAVAILABLE_ATTRIBUTE; 当然，不用担心组件内部如何获取父类特性，可以通过[super init]来处理。同时，在多人开发中，组件的开放方法名最好加入一些前缀，便于区别，也避免方法重名，最容易导致方法重名的情况就是各种分类里面的方法重复，会带来意想不到的错误。 19、缓存机制的设计不管是任何技术栈的缓存机制设计，都需要一套缓存淘汰算法，使用最广泛的淘汰算法就是 LRU，即是最近最少使用淘汰算法，开发者需要严格的控制磁盘缓存和内存缓存的空间占用。 在 iOS 开发中，可以使用 YYCache 来处理缓存机制，该框架的源码剖析可见笔者博客：YYCache 源码剖析：一览亮点 还有一点需要提出的是磁盘缓存的位置问题。iOS 设备沙盒中有 Documents、Caches、Preferences、tmp 等文件夹，其中 Documents 和 Preferences 会被 iCloud 同步。 Documents 适合存储比较重要的数据；Caches 适合存储大量且不那么重要的数据，比如图片缓存、网络数据缓存啥的；tmp 存储临时文件，重启手机或者内存告急时会被清理；Preferences 是偏好设置，适合存储比较个性化的数据。 值得注意的是，NSUserDefaults是存储在 Preferences 下的文件，发现有很多开发者为了偷懒频繁的使用NSUserDefaults做任意数据的磁盘缓存，这是一个很不合理的做法，用处不大且大量的数据一般缓存在 Caches 中，就算是从技术角度考虑，NSUserDefaults是以 .plist 形式存储的，不适合大数据存储。 20、合理选择数字类型软件工程师应该清楚自己编写的代码是运行在 32 位还是 64 位的系统上，并且了解编程语言对于各种数字类型的定义。 在 iOS 领域，CGFloat在 32 位系统中为 float 单精度，64 位系统中为 double 双精度，当将一个NSNumber转换为数字类型时，为了兼容，需要如下写： 1234567NSNumber *number = ...;CGFloat result = 0;#if CGFLOAT_IS_DOUBLE result = number.doubleValue;#else result = number.floatValue;#endif 在使用不同数字类型时，需要考虑数字类型的表示范围，比如能用short处理的就不要用long int。 同时，数字类型的精度问题往往困扰着新手开发者。不管是单精度 (float) 还是双精度 (double) 它们都是基于浮点计数实现的，包含了符号域、指数域、尾数域，而在计算机的理解里数字就是二进制，所以浮点数基于二进制的科学计数法形如：1.0101 * 2^n ，这可不像十进制那样方便的表示十进制小数，比如在十进制中使用 10^-1 轻松的表示十进制的 0.1 ，而二进制方式却无法实现（试想 2 的几次方等于十进制的 0.1 ？），所以浮点数只能用最大限度的近似值表示这些无法精确表示的小数。 比如写一句代码 float f = 0.1;打一个断点可以看到它实际的值是：f = 0.100000001。 和浮点计数相对的是定点计数，定点计数比较直观，比如：10.0101 ，它的弊端就是对于有效位数过多的数字，需要大量的空间来存储。所以为了存储空间的高效利用，使用最广泛的仍然是“不够精确”的基于浮点计数的单精度和双精度类型。 然而，在一些特定场景下，定点计数仍然能发挥它的优势，比如金钱计算。 对于金钱计算的处理，往往都是要求绝对准确的，所以在很多语言中都有基于定点计数的数据类型，比如 Java 中的 BigDecimal、Objective-C 中的 NSDecimalNumber，牺牲一些空间和时间来达到精确的计算。","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]}]}