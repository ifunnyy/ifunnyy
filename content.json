{"meta":{"title":"ifunnyy","subtitle":null,"description":"仰天大笑出门去 我辈岂是蓬蒿人","author":"Johnny","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-10-06T11:29:21.000Z","updated":"2018-08-14T09:14:30.320Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-06T11:29:21.000Z","updated":"2018-08-14T09:21:18.333Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深拷贝和浅拷贝","slug":"objective-c/深拷贝和浅拷贝","date":"2018-08-14T14:17:00.000Z","updated":"2018-08-14T14:17:33.196Z","comments":true,"path":"2018/08/14/objective-c/深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2018/08/14/objective-c/深拷贝和浅拷贝/","excerpt":"","text":"#copy和mutablecopy copy: 拷贝出来的对象类型总是不可变类型 (例如: NSString, NSDictionary, NSArray) mutableCopy: 拷贝出来的对象类型总是可变类型 (例如: NSMutableString, NSMutableDictionary, NSMutableArray) 12345678910111213141516NSString *string1 = @&quot;123&quot;;NSString *string2 = [string1 copy];NSString *string3 = [string1 mutableCopy];NSMutableString *string4 = [string1 mutableCopy];NSMutableString *string5 = [string1 copy];output-p string1:(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;output-p string2:(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;output-p string3:(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;output-p string4:(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;output-p string5:(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot; 注意： 在runtime下NSString的”真身”是NSCFConstantString，而NSMutableString的”真身”是NSCFString，然后我们就能很清楚的看到，只要是copy得到的值就是不可变类型，而mutablecopy得到的是可变类型。 NSTaggedPointerString为苹果在64位对NSString和NSNumber等对象的优化 #深拷贝和浅拷贝 imutableObject为不可变对象，如: NSString, NSArray等 mutableObject为可变对象，如: NSMutableString, NSMutableArray等 在imutableObject对象中: 对 immutable 对象进行 copy 操作，是指针复制【浅拷贝】，mutableCopy 操作时内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下： 123456789101112131415161718192021222324252627[immutableObject copy] //浅复制[immutableObject mutableCopy] //深复制[mutableObject copy] //深复制[mutableObject mutableCopy] //深复制NSString *string1 = @&quot;123&quot;;NSString *string2 = [string1 copy];NSMutableString *string3 = [string1 mutableCopy];NSMutableString *string4 = [NSMutableString stringWithFormat:@&quot;123&quot;];NSString *string5 = [string4 copy];NSMutableString *string6 = [string1 mutableCopy];output-p string1:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p string2:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p string3:(__NSCFString *) = 0x000000010041eb10 @&quot;123&quot;output-p string4:(__NSCFString *) = 0x000000010342ceb0 @&quot;123&quot;output-p string5:(NSTaggedPointerString *) = 0x0000000033323135 @&quot;123&quot;output-p string6:(__NSCFString *) = 0x000000010342c830 @&quot;123&quot; 可以看出，除了对immutable的Copy动作得到的string是浅拷贝外，其他的都是深拷贝。 在mutableObject对象中: 对 immutable 对象进行 copy，是指针复制【浅拷贝】， mutableCopy 是内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。 1234567891011121314151617181920212223242526272829303132333435363738394041[immutableObject copy] // 浅复制[immutableObject mutableCopy] //单层深复制[mutableObject copy] //单层深复制[mutableObject mutableCopy] //单层深复制NSString *string1 = @&quot;123&quot;;NSArray *array1 = @[string1];NSArray *array2 = [array1 copy];NSMutableArray *array3 = [array1 mutableCopy]; NSMutableArray *array4 = @[string1];NSArray *array5 = [array4 copy];NSMutableArray *array6 = [array4 mutableCopy];output-p string1:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array1:(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;output-p array1[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array2:(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;output-p array2[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array3:(__NSArrayM *) = 0x00000001004002e0 @&quot;1 element&quot;output-p array3[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array4:(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;output-p array4[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array5:(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;output-p array5[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;output-p array6:(__NSArrayM *) = 0x000000010041ec30 @&quot;1 element&quot;output-p array6[0]:(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot; 这里说的单层深复制其实就是所谓的不完全深拷贝，这个跟Java中的深拷贝概念又有所区别，iOS中集合对象的“深拷贝”只拷贝了一个壳，对于壳内的元素是浅拷贝，和java中递归的深拷贝有所不同。 #property中的copy属性 123456789@property (copy, nonatomic) NSString *someString;- (void)setSomeString:(NSString *)someString&#123; //没有写copy属性时 _someString = someString; //写了copy属性时 _someString = [someString copy];&#125; 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。 也就是说，当你加上一个copy属性时，这个对象在被set的时，就不再是改变这个对象的原有内存，而是修改这个对象的不可变副本内存。这样就能够保证这个元素不会被外部修改影响。 1234567891011121314@property(nonatomic, strong) NSArray *array;NSArray *array = @[@1, @2, @3, @4];NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array];self.array = mutableArray;[mutableArray removeAllObject];NSLog(@&quot;%@&quot;, self.array);output:&lt;__NSArrayM 0x60800025a9d0&gt;()这就是property里不用copy而用strong的结果，当你确定这个元素是不可变的，那么copy属性还是很有必要的","categories":[{"name":"objective-c","slug":"objective-c","permalink":"http://yoursite.com/categories/objective-c/"}],"tags":[]},{"title":"arguments","slug":"arguments","date":"2018-08-14T04:00:00.000Z","updated":"2018-08-14T09:20:37.123Z","comments":true,"path":"2018/08/14/arguments/","link":"","permalink":"http://yoursite.com/2018/08/14/arguments/","excerpt":"","text":"arguments.calleearguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，返回正被执行的 Function 对象，也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性。 比如阶乘算法: 12345678var num = (function (n) &#123; if (n == 1) &#123; return 1; &#125; return n * arguments.callee(n - 1);&#125;(5))console.log(num); 12output:120 现在已经不推荐使用arguments.callee()； 原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。 现在arguments.callee 被弃用了。怎么办，其实很简单，给内部函数一个名字即可（当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。） 123456var num = (function fn(n) &#123; if (n == 1) &#123; return 1; &#125; return n * fn(n - 1);&#125;(5))","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"arguments","slug":"arguments","permalink":"http://yoursite.com/tags/arguments/"},{"name":"callee","slug":"callee","permalink":"http://yoursite.com/tags/callee/"}]}]}