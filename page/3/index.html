<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="仰天大笑出门去 我辈岂是蓬蒿人">
<meta property="og:type" content="website">
<meta property="og:title" content="ifunnyy">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="ifunnyy">
<meta property="og:description" content="仰天大笑出门去 我辈岂是蓬蒿人">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ifunnyy">
<meta name="twitter:description" content="仰天大笑出门去 我辈岂是蓬蒿人">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: false,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>ifunnyy</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?95e48dc1b0014483f90b963827cc265d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ifunnyy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/javascript/语言篇/this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/javascript/语言篇/this/" itemprop="url">this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T14:11:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript随记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript随记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数预编译过程-this-gt-window"><a href="#函数预编译过程-this-gt-window" class="headerlink" title="函数预编译过程 this -&gt; window"></a>函数预编译过程 this -&gt; window</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test(c) &#123;</span><br><span class="line">	var a = 123;</span><br><span class="line">	function b() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">预编译产生AO</span><br><span class="line">AO &#123;</span><br><span class="line">	arguments: [1],</span><br><span class="line">	this: window,</span><br><span class="line">	c: 1,</span><br><span class="line">	a: undefines,</span><br><span class="line">	b: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test(c) &#123;</span><br><span class="line">	// var this = Object.create(test.prototype);</span><br><span class="line">	var a = 123;</span><br><span class="line">	function b() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">new test(1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">预编译产生AO</span><br><span class="line">AO &#123;</span><br><span class="line">	arguments: [1],</span><br><span class="line">	this: obj,</span><br><span class="line">	c: 1,</span><br><span class="line">	a: undefines,</span><br><span class="line">	b: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h1 id="全局作用域里-this-gt-window"><a href="#全局作用域里-this-gt-window" class="headerlink" title="全局作用域里 this -&gt; window"></a>全局作用域里 this -&gt; window</h1><h1 id="call-apply-可以改变函数运行时this指向"><a href="#call-apply-可以改变函数运行时this指向" class="headerlink" title="call/apply 可以改变函数运行时this指向"></a>call/apply 可以改变函数运行时this指向</h1><h1 id="obj-func-func-里面的this指向obj"><a href="#obj-func-func-里面的this指向obj" class="headerlink" title="obj.func(); func()里面的this指向obj"></a>obj.func(); func()里面的this指向obj</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	show: function() &#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;,</span><br><span class="line">	name: &apos;abc&apos;</span><br><span class="line">&#125;</span><br><span class="line">obj.show()</span><br></pre></td></tr></table></figure>
<p>谁调用show，里面的this就指向谁</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/javascript/语言篇/原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/javascript/语言篇/原型链/" itemprop="url">原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T14:07:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript随记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript随记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h1><p>定义：原型是function对象的一个属性，它定义了构造函数制造的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</p>
<p>利用原型特点和概念，可以提取公有属性</p>
<p>对象如何查找原型 -&gt; 隐式属性 __proto__</p>
<p>对象如何查找对象的构造函数 -&gt; constructor</p>
<p>函数默认就会自动生成prototype这个空对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//或者可以写Person.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	lastName: &apos;Lin&apos;</span><br><span class="line">&#125;</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.show = function () &#123;</span><br><span class="line">		console.log(this.lastName + &apos; &apos; + this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;Johnnny&apos;);</span><br><span class="line">person.log();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">Lin Johnny</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">//这里会隐性调用 var this = &#123; __proto__: Person.prototype &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;ccc&apos;;</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &apos;sunny&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以更改__proto__，让它指向其他原型</span><br><span class="line">person.__proto__ = obj;</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">ccc</span><br><span class="line">ccc</span><br><span class="line">sunny</span><br><span class="line">sunny</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = &apos;abc&apos;;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">	//这里会隐性调用 var this = &#123; __proto__: Person.prototype &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__.name);</span><br><span class="line">console.log(person.name);</span><br><span class="line"></span><br><span class="line">//解释为Person.prototype更换了一个新的对象，但是原来的Person.__proto__的指向还是原来的对象</span><br><span class="line">//Person.prototype = &#123;name: &apos;a&apos;&#125;;</span><br><span class="line">//__proto__ = Person.prototype;</span><br><span class="line">//Person.prototype = &#123;name: &apos;b&apos;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name: &apos;sunny&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person1.__proto__.name);</span><br><span class="line">console.log(person1.name);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">sunny</span><br><span class="line">sunny</span><br></pre></td></tr></table></figure>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>如何构成原型链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Grand() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var grand = new Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype = grand;</span><br><span class="line">function Father() &#123;</span><br><span class="line">	this.name = &apos;Johnny&apos;</span><br><span class="line">&#125;</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = father;</span><br><span class="line">function Son() &#123;</span><br><span class="line">	this.old = 2</span><br><span class="line">&#125;</span><br><span class="line">var son = new Son();</span><br></pre></td></tr></table></figure>
<p>特殊的修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.lastName = &apos;Lin&apos;;</span><br><span class="line">function Grand() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var grand = new Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype = grand;</span><br><span class="line">function Father() &#123;</span><br><span class="line">	this.name = &apos;Johnny&apos;,</span><br><span class="line">	this.forturn = &#123;</span><br><span class="line">		&apos;card1&apos;: &apos;Visa&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var father = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = father;</span><br><span class="line">function Son() &#123;</span><br><span class="line">	this.old = 2</span><br><span class="line">&#125;</span><br><span class="line">var son = new Son();</span><br><span class="line"></span><br><span class="line">console.log(son.forturn);</span><br><span class="line"></span><br><span class="line">//这个修改是直接获取引用值进行修改</span><br><span class="line">son.forturn.card2 = &apos;UnionPay&apos;;</span><br><span class="line">console.log(son.forturn);</span><br><span class="line"></span><br><span class="line">//这个修改是直接从新赋值</span><br><span class="line">son.forturn = &apos;200&apos;;</span><br><span class="line">console.log(son.forturn);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">&#123;&apos;card1&apos;: &apos;Visa&apos;&#125;</span><br><span class="line">&#123;&apos;card1&apos;: &apos;Visa&apos;, &apos;card2&apos;: &apos;UnionPay&apos;&#125;</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<p>Test</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">	name: &apos;a&apos;,</span><br><span class="line">	sayName: function() &#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person() &#123;</span><br><span class="line">	this.name = &apos;b&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">//谁调用sayName这个方法，里面的this就指向谁</span><br><span class="line">console.log(person.sayName());</span><br><span class="line">console.log(Person.prototype.sayName());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>绝大多数对象的最终都会继承自Object.prototype</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;     // --&gt; new Object();</span><br><span class="line">//相当于 var obj = new Object();     少用，尽量用字面量</span><br><span class="line">//obj.__proto__ == Object.prototype</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;&#125;;  //--&gt; Object.prototype</span><br></pre></td></tr></table></figure>
<p>不会继承Object.prototype的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//null</span><br><span class="line">var obj = Object.create(null);</span><br></pre></td></tr></table></figure>
<p>Object.create(原型)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//var obj = Object.create(原型);</span><br><span class="line">var obj = &#123;name: &apos;sunny&apos;, age: 123&#125;;</span><br><span class="line">var obj1 = Object.create(obj);</span><br><span class="line">console.log(obj1.__proto__);</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;name: &apos;sunny&apos;, age: 123&#125;;</span><br><span class="line">function Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var person = Object.create(Person.prototype);</span><br><span class="line">console.log(person.__proto__);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">&#123;name: &apos;sunny&apos;, age: 123&#125;</span><br><span class="line">&#123;name: &apos;sunny&apos;, age: 123&#125;</span><br></pre></td></tr></table></figure>
<h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h1><p>作用，改变this指向。</p>
<p>call/apply区别，后面传的参数形式不同。</p>
<ol>
<li>call 需要把实参按照形参的个数传进去</li>
<li>apply 需要传一个arguments</li>
</ol>
<p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。 </p>
<p>call</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test() // ---&gt; test.call();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Person里面的this已经改变成obj了。</span><br><span class="line">Person.call(obj, &apos;cheng&apos;, 300);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">	this.name = &apos;Lin &apos; + name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, sex, tel, grade) &#123;</span><br><span class="line">	//* var this = &#123;&#125;;</span><br><span class="line">	// 改变this的指向，所以用Person里面的方法去封装this，封装后变成</span><br><span class="line">	// var this = &#123;name: &apos;Lin Johnny&apos;, age: 123, sex: &apos;male&apos;&#125;;</span><br><span class="line">	</span><br><span class="line">	Person.call(this, name, age, sex);</span><br><span class="line">	this.tel = tel;</span><br><span class="line">	this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017);</span><br></pre></td></tr></table></figure>
<p>apply</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, sex) &#123;</span><br><span class="line">	this.name = &apos;Lin &apos; + name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, age, sex, tel, grade) &#123;</span><br><span class="line">	//* var this = &#123;&#125;;</span><br><span class="line">	// 改变this的指向，所以用Person里面的方法去封装this，封装后变成</span><br><span class="line">	// var this = &#123;name: &apos;Lin Johnny&apos;, age: 123, sex: &apos;male&apos;&#125;;</span><br><span class="line">	</span><br><span class="line">	//跟call的区别就是参数不同，apply除了指向，其余参数都包含在数组里面</span><br><span class="line">	Person.apply(this, [name, age, sex]);</span><br><span class="line">	this.tel = tel;</span><br><span class="line">	this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = new Student(&apos;Johnny&apos;, 123, &apos;male&apos;, 139, 2017);</span><br></pre></td></tr></table></figure>
<p>bind</p>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var bar = function() &#123;   </span><br><span class="line">  console.log(this.x);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo=&#123;</span><br><span class="line">	x:3   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">var func = bar.bind(foo);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/javascript/语言篇/函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/javascript/语言篇/函数/" itemprop="url">函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T14:05:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript随记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript随记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var abs = function(x) &#123;</span><br><span class="line">	if (x &gt;= 0) &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return -x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(abs(10));</span><br></pre></td></tr></table></figure>
<p>这种形式看起来好像是常规的变量赋值语句。但是函数表达式和函数声明的区别在于，函数表达式在使用前必须先赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(abs(10));</span><br><span class="line">function abs(x) &#123;</span><br><span class="line">	if (x &gt;= 0) &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return -x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">一般定义函数不会出错</span><br><span class="line"></span><br><span class="line">console.log(abs(10));</span><br><span class="line">var abs = function(x) &#123;</span><br><span class="line">	if (x &gt;= 0) &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return -x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">报错，显示undefined is not a function</span><br></pre></td></tr></table></figure>
<p>造成这种现象是因为解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它的所在的的代码行，才会真正的被解析。</p>
<p>函数表达式中，创建的函数叫做匿名函数，因为function关键字后面没有标识符。</p>
<h1 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">	var a = 123;</span><br><span class="line">	var b = 456;</span><br><span class="line">	console.log(a + b);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>两种立即执行函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;&#125;()); W3C 建议第一种</span><br><span class="line">(function()&#123;&#125;)();</span><br></pre></td></tr></table></figure>
<p>只有表达式才能被执行符号执行, 把函数放在()里面就会被转成表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function () &#123;</span><br><span class="line">&#125;</span><br><span class="line">这不是表达式，这是函数</span><br></pre></td></tr></table></figure>
<p>函数能够被立即执行，执行完后函数被放弃，test不再代表函数，能被符号执行的函数，就会变成立即执行函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var test = function () &#123;</span><br><span class="line">	console.log(&apos;a&apos;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>有正负和叹号或者或与在前面自动变成表达式，所以可以立即执行，然后忽略函数名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(function(test)&#123;</span><br><span class="line">	console.log(test);      //输出123，使用()运算符</span><br><span class="line">&#125;(123));</span><br><span class="line"></span><br><span class="line">(function(test)&#123;</span><br><span class="line">	console.log(test);      //输出123，使用()运算符</span><br><span class="line">&#125;)(123);</span><br><span class="line"></span><br><span class="line">!function(test)&#123;</span><br><span class="line">	console.log(test);      //输出123，使用!运算符</span><br><span class="line">&#125;(123);</span><br><span class="line"></span><br><span class="line">+function(test)&#123;</span><br><span class="line">	console.log(test);      //输出123，使用+运算符</span><br><span class="line">&#125;(123);</span><br><span class="line"></span><br><span class="line">-function(test)&#123;</span><br><span class="line">	console.log(test);      //输出123，使用-运算符</span><br><span class="line">&#125;(123);</span><br><span class="line"></span><br><span class="line">var fn = function(test)&#123;</span><br><span class="line">	console.log(test);      //输出123，使用=运算符</span><br><span class="line">&#125;(123);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test(a, b, c, d) &#123;</span><br><span class="line">	console.log(a + b + c + d);</span><br><span class="line">&#125;(1, 2, 3, 4);</span><br><span class="line">这个不报错，系统把它分成了函数和后面参数，test现在变成了函数。</span><br><span class="line">如果括号里面不加东西，那么就会报错。</span><br></pre></td></tr></table></figure>
<p>使用立即执行函数的好处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可，如jQuery代码结构。</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="实现公有变量"><a href="#实现公有变量" class="headerlink" title="实现公有变量"></a>实现公有变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eg: 函数累加器</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">	var num = 0;</span><br><span class="line">	function a() &#123;</span><br><span class="line">		num++;</span><br><span class="line">		console.log(num);</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数a保留着函数add的AO</span><br><span class="line">var myAdd = add();</span><br><span class="line">myAdd();               1</span><br><span class="line">myAdd();               2</span><br><span class="line">myAdd();               3</span><br></pre></td></tr></table></figure>
<h2 id="可以做缓存（存储结构）"><a href="#可以做缓存（存储结构）" class="headerlink" title="可以做缓存（存储结构）"></a>可以做缓存（存储结构）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">	var food = &apos;apple&apos;;</span><br><span class="line">	var obj = &#123;</span><br><span class="line">		eatFood: function() &#123;</span><br><span class="line">			if (food != &apos;&apos;) &#123;</span><br><span class="line">				console.log(&apos;eating &apos; + food);</span><br><span class="line">				food = &quot;&quot;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				console.log(&apos;nothing&apos;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		pushFood: function(myFood) &#123;</span><br><span class="line">			food = myFood;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = test();</span><br><span class="line">a.edtFood();              eating apple</span><br><span class="line">a.edtFood();              noting</span><br><span class="line">a.pushFood(&apos;banana&apos;);     </span><br><span class="line">a.edtFood();              eating banana</span><br></pre></td></tr></table></figure>
<h2 id="可以实现封装，属性私有化"><a href="#可以实现封装，属性私有化" class="headerlink" title="可以实现封装，属性私有化"></a>可以实现封装，属性私有化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, money) &#123;</span><br><span class="line">	var lunch = 15;</span><br><span class="line"></span><br><span class="line">	this.name = name;</span><br><span class="line">	this.money = money;</span><br><span class="line">	</span><br><span class="line">	this.eat = function() &#123;</span><br><span class="line">		this.money = this.money - lunch;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	this.buffet = function() &#123;</span><br><span class="line">		lunch = 15;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	this.mee = function() &#123;</span><br><span class="line">		lunch = 12;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	this.getLunch = function() &#123;</span><br><span class="line">		console.log(lunch);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&apos;Johnny&apos;, 100);</span><br><span class="line">person.buffet();</span><br><span class="line">person.getLunch();</span><br><span class="line">person.eat();</span><br><span class="line">person.mee();</span><br><span class="line">person.getLunch();</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Block&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        ul &#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">        &#125;</span><br><span class="line">        li:nth-of-type(2n) &#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        li:nth-of-type(2n + 1) &#123;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;c&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;d&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var liCollection = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">    for (var i = 0; i &lt; liCollection.length; i++) &#123;</span><br><span class="line">        //闭包的应用</span><br><span class="line">        (function (k) &#123;</span><br><span class="line">            liCollection[k].addEventListener(&quot;click&quot;, function () &#123;</span><br><span class="line">                console.log(k);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;(i))</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/javascript/语言篇/对象、包装类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/javascript/语言篇/对象、包装类/" itemprop="url">对象、包装类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T14:03:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript随记/" itemprop="url" rel="index">
                    <span itemprop="name">javascript随记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">	name: &apos;Johnny&apos;,</span><br><span class="line">	old: 25,</span><br><span class="line">	nextYear: function() &#123;</span><br><span class="line">		this.old = this.old + 1;</span><br><span class="line">	&#125;,</span><br><span class="line">	lastYear: function() &#123;</span><br><span class="line">		this.old = this.old - 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>删除属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete person.old;</span><br></pre></td></tr></table></figure>
<h1 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、plainObject  对象字面量/对象直接量</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">2、构造函数</span><br><span class="line">	2.1、系统自带的构造函数</span><br><span class="line">		Object() Array() var obj = new Object();</span><br><span class="line">	2.2、自定义</span><br><span class="line">		function Car(color) &#123;</span><br><span class="line">			//里面会隐性调用，可以选择不写，用*来标识</span><br><span class="line">			//* var this = &#123;</span><br><span class="line">			//*    __proto__: Car.prototype</span><br><span class="line">			//* &#125;;</span><br><span class="line">			this.name = &apos;BMW&apos;;</span><br><span class="line">			this.wheel = 4;</span><br><span class="line">			this.color = color;</span><br><span class="line">			//* return this;</span><br><span class="line">			</span><br><span class="line">			//如果手动return其他值，除非是对象，否则都会自动变成this，比如：</span><br><span class="line">			//return [1, 2, 3];    output: [1, 2, 3]</span><br><span class="line">			//return 1;            output: Car &#123;name: &apos;BMW&apos;, ...&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		var car = new Car(&apos;red&apos;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(123);      output: Number&#123;123&#125;</span><br><span class="line">num.abc = &apos;123&apos;;                output: Number&#123;123, abc: &apos;123&apos;&#125;</span><br><span class="line">num + 10;                       output: 133 返回一个整型值</span><br><span class="line"></span><br><span class="line">var bol = new Boolean(&apos;true&apos;); </span><br><span class="line">output: Boolean&#123;[[PrimitiveValue]]: true&#125;</span><br><span class="line"></span><br><span class="line">undefined和null不能设置属性</span><br></pre></td></tr></table></figure>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num = 4;</span><br><span class="line">num.len = 3;    </span><br><span class="line">-&gt; 隐性调用 new Number(4).len = 3; 然后再调用delete</span><br><span class="line"></span><br><span class="line">console.log(num.len);   </span><br><span class="line">-&gt; 隐性调用 new Number(4).len; 然后再输出</span><br><span class="line">output: undefined</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Test:</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.length = 2;</span><br><span class="line">console.log(arr);     output: [1, 2]</span><br><span class="line"></span><br><span class="line">var str = &apos;abcd&apos;;</span><br><span class="line">str.length = 2;</span><br><span class="line">-&gt; 因为str是基础类型，直接给它的属性赋值会隐性调用 new String(&apos;abcd&apos;).len = 2; 然后再调用delete</span><br><span class="line"></span><br><span class="line">console.log(str);     output: abcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">str += 1;                 //str == &apos;abc1&apos;;</span><br><span class="line">var test = typeof str;</span><br><span class="line">if (test.length == 6) &#123;</span><br><span class="line">	-&gt; 因为str是基础类型，直接给它的属性赋值会隐性调用 new String(&apos;abc1&apos;).sign = &apos;typeof的返回结果可能为String&apos;; 然后再调用delete</span><br><span class="line">	</span><br><span class="line">	test.sign = &apos;typeof的返回结果可能为String&apos;;</span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line">-&gt; test.sign会隐性调用 new String(test).sign，然后输出test.sign</span><br><span class="line">console.log(test.sign).     output: undefined</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/objective-c/在MRC下的内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/objective-c/在MRC下的内存管理/" itemprop="url">在MRC下的内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T13:46:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/objective-c/" itemprop="url" rel="index">
                    <span itemprop="name">objective-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下的解释全部都在MRC环境下</p>
<ol>
<li>自己持有的对象，自己所持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时，应该要释放。</li>
<li>非自己持有的对象无法释放。</li>
</ol>
<p>对象操作与Objective-C方法的对应</p>
<table>
<thead>
<tr>
<th style="text-align:left">对象操作</th>
<th style="text-align:left">Objective-C 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">生成并持有对象</td>
<td style="text-align:left">alloc/new/copy/mutableCopy 等方法</td>
</tr>
<tr>
<td style="text-align:left">持有对象</td>
<td style="text-align:left">retain 方法</td>
</tr>
<tr>
<td style="text-align:left">释放对象</td>
<td style="text-align:left">release 方法</td>
</tr>
<tr>
<td style="text-align:left">废弃对象</td>
<td style="text-align:left">dealloc 方法</td>
</tr>
</tbody>
</table>
<h1 id="自己生成的对象，自己所持有"><a href="#自己生成的对象，自己所持有" class="headerlink" title="自己生成的对象，自己所持有"></a>自己生成的对象，自己所持有</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自己生成并持有对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">id obj = [NSObject new];</span><br><span class="line"></span><br><span class="line">// 自己持有对象</span><br></pre></td></tr></table></figure>
<p>copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本。与copy方法类似，mutableCopy方法利用基于NSMutableCopying方法约定，由各类实现的mutableCopyWithZone:方法生成并持有对象的副本。两者的区别在于copy方法生成不可变更的对象，而mutableCopy方法生成可变更的对象。虽然是对象的副本，但同alloc、new方法一样，在“自己生成并持有对象”这点上没有改变。</p>
<h1 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 取得非自己生成并持有的对象</span><br><span class="line">id obj = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">// 取得的对象存在，但自己不持有对象</span><br><span class="line"></span><br><span class="line">[obj retain];</span><br><span class="line">// 调用retain，自己持有对象</span><br></pre></td></tr></table></figure>
<p>通过retain方法，非自己生成的对象跟用alloc/new/copy/mutableCopy方法生成并持有的对象一样，成为了自己所持有的</p>
<h1 id="不再需要自己持有的对象时释放"><a href="#不再需要自己持有的对象时释放" class="headerlink" title="不再需要自己持有的对象时释放"></a>不再需要自己持有的对象时释放</h1><p>自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用release方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 自己生成并持有对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">// 自己持有对象</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line"></span><br><span class="line">指向对象的指针仍然被保留在变量obj中，貌似能够访问。</span><br><span class="line">但对象一经释放绝对不可访问。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 取得非自己生成并持有的对象</span><br><span class="line">id obj = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">// 取得的对象存在，但自己不持有对象</span><br><span class="line"></span><br><span class="line">[obj retain];</span><br><span class="line">// 调用retain，自己持有对象</span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line">对象不可再被访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>用alloc/new/copy/mutableCopy方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。</p>
<p>如果要用某个方法生成对象，并将其返回该方法的调用方，那么它的源代码是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject &#123;</span><br><span class="line">	//自己生成并持有对象</span><br><span class="line">	id obj = [[NSObject alloc] init];</span><br><span class="line">	</span><br><span class="line">	//自己持有对象</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">如上所示，原封不动地返回用alloc方法生成并持有的对象，就能让调用方也持有该对象。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 取得非自己生成并持有的对象</span><br><span class="line">id obj = [self allocObject];</span><br><span class="line"></span><br><span class="line">//自己持有对象</span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line">对象不可再被访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>那么，调用[NSMutableArray array]方法使取得的对象存在，但自己不持有对象，又是如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (id)object &#123;</span><br><span class="line">	//自己生成并持有对象</span><br><span class="line">	id obj = [[NSObject alloc] init];</span><br><span class="line">	</span><br><span class="line">	[obj autorelease];</span><br><span class="line">	</span><br><span class="line">	//取得的对象存在，但自己不持有对象</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取得非自己生成的对象，但自己不持有对象</span><br><span class="line">id obj = [self object];</span><br><span class="line"></span><br><span class="line">// 自己持有对象</span><br><span class="line">[obj retain];</span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line">/*</span><br><span class="line">释放对象</span><br><span class="line">对象不可再被访问</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>我们使用autorelease方法。用该方法，可以使取得的对象存在，单自己不持有对象。autorelease提供这样的功能，使对象在超出指定的生存范围时能够自动并正确的释放(调用release方法)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/objective-c/提高调用Objective-C方法的速度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/objective-c/提高调用Objective-C方法的速度/" itemprop="url">提高调用Objective-C方法的速度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T13:21:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/objective-c/" itemprop="url" rel="index">
                    <span itemprop="name">objective-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>GNUseto中的autorelease实际上是用一种特殊的方法来实现的。这种方法能够高效地运行OSX, iOS应用程序中频繁调用autorelease方法，它被称为”IMP Caching”。</p>
<p>在进行调用时，为了解决类名/方法名以及取得方法运行时的函数指针，要在框架初始化时对其结果值进行换缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id autorelease_class = [NSAutoreleasePool class];</span><br><span class="line">SEL autorelease_sel = @selector(addObject:);</span><br><span class="line">IMP autorelease_imp = [autorelease_class methodForSelector:autorelease_sel];</span><br><span class="line"></span><br><span class="line">//实际调用就是使用缓存的结果值。</span><br><span class="line">- (id)autorelease &#123;</span><br><span class="line">	(*autorelease_imp)(autorelease_class, autorelease_sel, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是IMP Caching的方法调用。虽然同一下源代码完全相同，但从运行效率上看，即使它依赖于运行环境，一般而言速度也是其他方法的2倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)autorelease &#123;</span><br><span class="line">	[NSAutorelesePool addObject:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/objective-c/深拷贝和浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/objective-c/深拷贝和浅拷贝/" itemprop="url">深拷贝和浅拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T12:12:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/objective-c/" itemprop="url" rel="index">
                    <span itemprop="name">objective-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="copy和mutablecopy"><a href="#copy和mutablecopy" class="headerlink" title="copy和mutablecopy"></a>copy和mutablecopy</h1><ol>
<li><p>copy: 拷贝出来的对象类型总是不可变类型<br>  (例如: NSString, NSDictionary, NSArray)</p>
</li>
<li><p>mutableCopy: 拷贝出来的对象类型总是可变类型<br>  (例如: NSMutableString, NSMutableDictionary, NSMutableArray) </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSString *string2 = [string1 copy];</span><br><span class="line">NSString *string3 = [string1 mutableCopy];</span><br><span class="line">NSMutableString *string4 = [string1 mutableCopy];</span><br><span class="line">NSMutableString *string5 = [string1 copy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string2:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string3:</span><br><span class="line">(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string4:</span><br><span class="line">(__NSCFString *) $1 = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string5:</span><br><span class="line">(__NSCFConstantString *) $0 = 0x0000000100001050 @&quot;123&quot;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>在runtime下NSString的”真身”是<strong>NSCFConstantString，而NSMutableString的”真身”是</strong>NSCFString，然后我们就能很清楚的看到，只要是copy得到的值就是不可变类型，而mutablecopy得到的是可变类型。</p>
<p>NSTaggedPointerString为苹果在64位对NSString和NSNumber等对象的优化</p>
<p>#深拷贝和浅拷贝</p>
<p>imutableObject为不可变对象，如: NSString, NSArray等</p>
<p>mutableObject为可变对象，如: NSMutableString, NSMutableArray等</p>
<p><strong>在imutableObject对象中:</strong></p>
<p>对 immutable 对象进行 copy 操作，是指针复制【浅拷贝】，mutableCopy 操作时内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy]           //浅复制</span><br><span class="line">[immutableObject mutableCopy]    //深复制</span><br><span class="line">[mutableObject copy]             //深复制</span><br><span class="line">[mutableObject mutableCopy]      //深复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSString *string2 = [string1 copy];</span><br><span class="line">NSMutableString *string3 = [string1 mutableCopy];</span><br><span class="line"></span><br><span class="line">NSMutableString *string4 = [NSMutableString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">NSString *string5 = [string4 copy];</span><br><span class="line">NSMutableString *string6 = [string1 mutableCopy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string2:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p string3:</span><br><span class="line">(__NSCFString *) = 0x000000010041eb10 @&quot;123&quot;</span><br><span class="line">output-p string4:</span><br><span class="line">(__NSCFString *) = 0x000000010342ceb0 @&quot;123&quot;</span><br><span class="line">output-p string5:</span><br><span class="line">(NSTaggedPointerString *) = 0x0000000033323135 @&quot;123&quot;</span><br><span class="line">output-p string6:</span><br><span class="line">(__NSCFString *) = 0x000000010342c830 @&quot;123&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出，除了对immutable的Copy动作得到的string是浅拷贝外，其他的都是深拷贝。</p>
<p><strong>在mutableObject对象中:</strong></p>
<p>对 immutable 对象进行 copy，是指针复制【浅拷贝】， mutableCopy 是内容复制【深拷贝】；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[immutableObject copy] // 浅复制</span><br><span class="line">[immutableObject mutableCopy] //单层深复制</span><br><span class="line">[mutableObject copy] //单层深复制</span><br><span class="line">[mutableObject mutableCopy] //单层深复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *string1 = @&quot;123&quot;;</span><br><span class="line">NSArray *array1 = @[string1];</span><br><span class="line">NSArray *array2 = [array1 copy];</span><br><span class="line">NSMutableArray *array3 = [array1 mutableCopy]; </span><br><span class="line">NSMutableArray *array4 = @[string1];</span><br><span class="line">NSArray *array5 = [array4 copy];</span><br><span class="line">NSMutableArray *array6 = [array4 mutableCopy];</span><br><span class="line"></span><br><span class="line">output-p string1:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array1:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;</span><br><span class="line">output-p array1[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array2:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041c4e0 @&quot;1 element&quot;</span><br><span class="line">output-p array2[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array3:</span><br><span class="line">(__NSArrayM *) = 0x00000001004002e0 @&quot;1 element&quot;</span><br><span class="line">output-p array3[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array4:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;</span><br><span class="line">output-p array4[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array5:</span><br><span class="line">(__NSSingleObjectArrayI *) = 0x000000010041ec20 @&quot;1 element&quot;</span><br><span class="line">output-p array5[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br><span class="line">output-p array6:</span><br><span class="line">(__NSArrayM *) = 0x000000010041ec30 @&quot;1 element&quot;</span><br><span class="line">output-p array6[0]:</span><br><span class="line">(__NSCFConstantString *) = 0x0000000100001050 @&quot;123&quot;</span><br></pre></td></tr></table></figure>
<p>这里说的单层深复制其实就是所谓的不完全深拷贝，这个跟Java中的深拷贝概念又有所区别，iOS中集合对象的“深拷贝”只拷贝了一个壳，对于壳内的元素是浅拷贝，和java中递归的深拷贝有所不同。</p>
<h1 id="property中的copy属性"><a href="#property中的copy属性" class="headerlink" title="property中的copy属性"></a>property中的copy属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) NSString *someString;</span><br><span class="line"></span><br><span class="line">- (void)setSomeString:(NSString *)someString</span><br><span class="line">&#123;</span><br><span class="line">  //没有写copy属性时</span><br><span class="line">  _someString = someString;</span><br><span class="line">  //写了copy属性时</span><br><span class="line">  _someString = [someString copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</li>
</ol>
<p>也就是说，当你加上一个copy属性时，这个对象在被set的时，就不再是改变这个对象的原有内存，而是修改这个对象的不可变副本内存。这样就能够保证这个元素不会被外部修改影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, strong) NSArray *array;</span><br><span class="line"></span><br><span class="line">NSArray *array = @[@1, @2, @3, @4];</span><br><span class="line">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array];</span><br><span class="line">self.array = mutableArray;</span><br><span class="line">[mutableArray removeAllObject];</span><br><span class="line">NSLog(@&quot;%@&quot;, self.array);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&lt;__NSArrayM 0x60800025a9d0&gt;(</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">这就是property里不用copy而用strong的结果，当你确定这个元素是不可变的，那么copy属性还是很有必要的</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/objective-c/何为代码质量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnny">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ifunnyy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/objective-c/何为代码质量/" itemprop="url">何为代码质量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T12:00:00+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/objective-c/" itemprop="url" rel="index">
                    <span itemprop="name">objective-c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、使用-i-而不是-i"><a href="#1、使用-i-而不是-i" class="headerlink" title="1、使用 ++i 而不是 i++"></a>1、使用 ++i 而不是 i++</h1><p>经常看到这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>单步自增 (或自减) 操作，最好是使用++i而不是i++，效率略高。</p>
<p>大家应该都知道++i的返回值是自增过后的，而i++的返回值是自增之前的。其实从这点就可以猜测：++i内部实现应该是直接将 i 这块内存 +1 然后返回，而i++需要使用一个局部变量来存储 i 的值，然后 i 加一，最后返回局部变量的值（别告诉我你能先 return 再执行自增）。</p>
<p>如果某一种语言的i++不能作为左值，那么也可以猜测这个局部变量是用const修饰的。</p>
<p>所以，i++理论上比++i有更多的消耗，代码就这样写吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;; ++i) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、巧用位运算"><a href="#2、巧用位运算" class="headerlink" title="2、巧用位运算"></a>2、巧用位运算</h1><p>位运算效率很高，而且有很多巧妙的用法，这里提出一个需求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">   TestEnumA = 1,</span><br><span class="line">   TestEnumB = 1 &lt;&lt; 1,</span><br><span class="line">   TestEnumC = 1 &lt;&lt; 2,</span><br><span class="line">   TestEnumD = 1 &lt;&lt; 3</span><br><span class="line">&#125; TestEnum;</span><br></pre></td></tr></table></figure>
<p>对于该多选枚举，如何判断该枚举类型的变量是否是复合项？</p>
<p>如果按照常规的思路，就需要逐项判断是否包含，时间复杂度最差为O(n)。而使用位运算可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestEnum test = …;</span><br><span class="line">if (test == (test &amp; (-test))) &#123;</span><br><span class="line">   //不是复合项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是通过负数二进制的一个特性来判断，看如下分析便一目了然：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test           0000 0100</span><br><span class="line">反码           1111 1011</span><br><span class="line">补码           1111 1100</span><br><span class="line">test &amp; (-test) 0000 0100</span><br></pre></td></tr></table></figure>
<h1 id="3、灵活使用组合运算符"><a href="#3、灵活使用组合运算符" class="headerlink" title="3、灵活使用组合运算符"></a>3、灵活使用组合运算符</h1><p>不明白有些工程师为什么排斥组合运算符，他们喜欢这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool is = …;</span><br><span class="line">if (is) a = 1;</span><br><span class="line">else a = 2;</span><br></pre></td></tr></table></figure>
<p>使用三目运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool is = …;</span><br><span class="line">a = is ? 1 : 2;</span><br></pre></td></tr></table></figure>
<p>其他组合运算符比如 ?: %=等，灵活的使用它们可以让代码更加的简洁清晰。</p>
<h1 id="4、const-和-static-和宏"><a href="#4、const-和-static-和宏" class="headerlink" title="4、const 和 static 和宏"></a>4、const 和 static 和宏</h1><p>static可以让变量进入静态区，提高变量生命周期至程序结束。值得注意的是，文件中最外层（#include下）的变量本身就是在静态区的，而这种情况使用static是为了变量的私有化。</p>
<p>const 修饰的变量在常量区不可变，是在编译阶段处理；宏是在预编译阶段执行宏替换。所以频繁使用 const 不会产生额外的内存，而所有使用宏的地方都可能开辟内存，况且，预编译阶段的大量宏替换会带来一定的时间消耗。</p>
<p>所以笔者的建议是，能用常量的不用宏，比如一个网络请求的 url：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// .h 接口文件</span><br><span class="line">extern NSString * const BaseServer;</span><br><span class="line"></span><br><span class="line">// .m 实现文件</span><br><span class="line">NSString * const BaseServer = @&quot;https://…&quot;;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，const 是修饰右边内存，所以这里是想要BaseServer字符串指针指向的内容不可变，而不是*BaseServer内容不可变。</p>
<h1 id="5、空间换时间"><a href="#5、空间换时间" class="headerlink" title="5、空间换时间"></a>5、空间换时间</h1><p>在很多场景中，可以牺牲一定的空间来降低时间复杂度，为了程序的高效运行，工程师可以自行判断是否值得，下面举一个代码例子，判断字符串是否有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL notEmpty(NSString *str) &#123;</span><br><span class="line">   if (!str) return NO;</span><br><span class="line">   static NSSet *emptySet;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       emptySet = [NSSet setWithObjects:@&quot;&quot;, @&quot;(null)&quot;, @&quot;null&quot;, @&quot;&quot;, @&quot;NULL&quot;, nil];</span><br><span class="line">   &#125;);</span><br><span class="line">   if ([emptySet containsObject:str]) return NO;</span><br><span class="line">   if ([str isKindOfClass:NSNull.class]) return NO;</span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一个 hash 来提高匹配效率，这在数据较少时可能体现不出优势，甚至会让效率变低，但是在数据量稍大的时候优势就明显了，而且这样写可以避免大量的if-elseif等判断，逻辑更清晰。</p>
<p>值得注意的是，此处使用static来提升局部变量emptySet的生命周期，而不是将这句代码写在方法体外面。在变量声明时，一定要明确它的使用范围，限定合适的作用域。</p>
<h1 id="6、容器类型的合理选择"><a href="#6、容器类型的合理选择" class="headerlink" title="6、容器类型的合理选择"></a>6、容器类型的合理选择</h1><p>在 C++ 中，若不需要键值对的 hash ，就使用set而不是map；若不需要排序的集合就使用unordered_set而不是sest。</p>
<p>归根结底也是对时间复杂度的考虑，选择容器类型时，一定要选择“刚好”能满足需求的，能用更“简单”效率更高的容器就不用“复杂”效率更低的容器。</p>
<h1 id="7、初始化不要交给编译器"><a href="#7、初始化不要交给编译器" class="headerlink" title="7、初始化不要交给编译器"></a>7、初始化不要交给编译器</h1><p>对于变量的使用，尽量在类或结构体初始化方法中对其赋初值，而不要依赖于编译器。因为在可见的未来，不管是编译器的更新或是代码跨平台移植，这些变量的初始值都不会受编译器影响。</p>
<h1 id="8、多分支结构处理"><a href="#8、多分支结构处理" class="headerlink" title="8、多分支结构处理"></a>8、多分支结构处理</h1><p>这是一个老生常谈的东西了，多分支结构尽量使用 switch 而不是大量的 if - else if 语句，若非要用 if - else if 来写，则出现频率高的分支优先判断，可以从整体上最大限度的减少判断次数。</p>
<p>不要小看这些少量的效率提升，放大到整个项目也是有不小的收益。</p>
<h1 id="9、避免数据同步"><a href="#9、避免数据同步" class="headerlink" title="9、避免数据同步"></a>9、避免数据同步</h1><p>经常会有一些需求，对一系列的数据有很多额外的操作，比如选择、删除、筛选、搜索等。代码设计时，要尽量将所有的操作状态都缓存到同一个数据模型中，而不是使用多个容器数据结构来处理，我们应该尽量避免数据同步防止出错。</p>
<h1 id="10、合理使用局部指针"><a href="#10、合理使用局部指针" class="headerlink" title="10、合理使用局部指针"></a>10、合理使用局部指针</h1><p>经常会看到这种代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething(city.school.class.jack.name,</span><br><span class="line">            city.school.class.jack.age,</span><br><span class="line">            city.school.class.jack.sex);</span><br></pre></td></tr></table></figure>
<p>当同一个变量的调用过深且使用频繁时，可以使用一个局部指针来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *jack = city.school.class.jack;</span><br><span class="line">doSomething(jack.name,</span><br><span class="line">            jack.age,</span><br><span class="line">            jack.sex);</span><br></pre></td></tr></table></figure>
<p>相对于指针变量所占用的空间来说，代码的简洁和美观度稍显重要一点。</p>
<h1 id="11、避免滥用单例"><a href="#11、避免滥用单例" class="headerlink" title="11、避免滥用单例"></a>11、避免滥用单例</h1><p>单例作为一种设计模式应用非常广泛，在移动端开发中，有些开发者利用它来实现非缓存传值，笔者认为这是一个错误的做法，使用单例传值的时候你需要管理单例中的数据何时释放与更新，可能会引发数据错乱。</p>
<p>单例存在的意义应该是缓存数据，而非传值，切勿为了方便滥用单例。</p>
<h1 id="12、避免滥用继承"><a href="#12、避免滥用继承" class="headerlink" title="12、避免滥用继承"></a>12、避免滥用继承</h1><p>继承本身和解耦思想有些冲突，代码设计中要尽量避免过深的继承关系，因为子类与父类的耦合将无法真正剥离。过深的继承关系会增加调试的困难程度，并且若继承关系设计有缺陷，修改越深的类影响面将会越广，可能带来灾难性的后果。</p>
<p>可以使用分类的方式做一些通用配置，然后在具体类中简洁的调用一次方法；也可以使用 AOP 思想，hook 住生命周期方法无侵入配置（比如埋点）。</p>
<p>比如 iOS 开发中，可能会有开发者喜欢写一套基类，实际上只是基于系统的类做了小量的配置，比如BaseViewController、BaseView、BaseModel、BaseViewModel，甚至是BaseTableViewCell。控制器基类可以对栈和导航栏做一些配置，还是有一点使用意义，至于其它的笔者感觉就是过度设计，其实很大意义上BaseViewController也没有存在的必要。</p>
<p>记住：过多的基类并不是代码规范，那是你囚禁其他开发者的牢笼。</p>
<h1 id="13、避免过度封装"><a href="#13、避免过度封装" class="headerlink" title="13、避免过度封装"></a>13、避免过度封装</h1><p>提取方法的原则是功能单一性，但若功能本身就是很少的一两句代码可能就没必要额外提取了。在保证代码清晰的情况下，很多时候提取逻辑也是需要酌情考虑的。</p>
<p>有见过开发者使用一套所谓的简洁配置 UI 的框架，不过就是将 UI 控件的属性封装成链式语法之类的，用起来有种快一些的错觉，殊不知这就是过度封装的典范。</p>
<p>封装的意义在于简洁的解决一类问题，而非少敲那几个字母，过度封装只会增加其他开发者阅读你代码的成本。</p>
<p>比如业界知名的 Masonry，使用它时比原生的 layout 快了不止 10 倍，而且代码很简洁易懂，极大的提高了开发效率。</p>
<h1 id="14、避免过多代码块嵌套"><a href="#14、避免过多代码块嵌套" class="headerlink" title="14、避免过多代码块嵌套"></a>14、避免过多代码块嵌套</h1><p>比如代码中大量的 if - else 嵌套判断，大量的嵌套循环，大量的闭包嵌套。</p>
<p>出现这种情况首先要考虑的是分支结构处理是否多余？循环是否可以优化时间复杂度？当排除这些可优化项过后，可以做一些方法提取减少大量的代码块嵌套，方便阅读。</p>
<h1 id="15、时刻注意空值和越界"><a href="#15、时刻注意空值和越界" class="headerlink" title="15、时刻注意空值和越界"></a>15、时刻注意空值和越界</h1><p>写某块代码中，要时刻注意空值和越界的处理，比如给NSDictionary插入空值会崩溃，从NSArray越界取值会崩溃，这些情况要时刻考虑到。</p>
<p>当然，可能有人会说有方法可以全局避免崩溃。实际上笔者不是很赞同这种做法，这可能会让新手开发者永远发现不了自己代码的漏洞。</p>
<h1 id="16、时刻注意代码的调用时机和频率"><a href="#16、时刻注意代码的调用时机和频率" class="headerlink" title="16、时刻注意代码的调用时机和频率"></a>16、时刻注意代码的调用时机和频率</h1><p>当你写一块代码时，需要习惯性的思考两个问题：这块代码的共有变量会被多线程访问从而存在安全问题么？这块代码可能会在一个 RunLoop 循环中调用很频繁么？</p>
<p>对于第一个问题，可能需要使用“锁”来保证线程安全，而锁的选择有一些技巧，比如整形使用原子自增保证线程安全：OSAtomicIncrement32()；调用耗时短的代码使用dispatch_semaphore_t更高效；可能存在重复获取锁时使用递归锁处理…</p>
<p>对于第二个问题，只需要在合适的地方加入自动释放池 (autoreleasepool) 避免内存峰值就行了。</p>
<h1 id="17、减少界面代码复用、增加功能代码的复用"><a href="#17、减少界面代码复用、增加功能代码的复用" class="headerlink" title="17、减少界面代码复用、增加功能代码的复用"></a>17、减少界面代码复用、增加功能代码的复用</h1><p>对于大前端来说，界面是项目中重要的组成部分，而有时候设计师给的图中，不同界面有很多相同的元素，看起来一模一样，所以很多工程师偷懒直接复用界面了。</p>
<p>在这里，笔者建议尽量少的复用界面，宁愿选择复制一份。</p>
<p>试想，目前版本两个界面相同，你复用了它，当下个版本其中一个界面要调整一下，这时你继续偷懒，加入一些判断来区分逻辑，下一次迭代又增加了差异，你又偷懒加入判断逻辑…… 最终你会发现，这个界面里面已经逻辑爆炸了，拆分成两个界面将变得异常困难。</p>
<p>而对于功能代码，笔者是提倡多提取，多复用，切记命名规范和适当的注释。</p>
<h1 id="18、组件的设计技巧"><a href="#18、组件的设计技巧" class="headerlink" title="18、组件的设计技巧"></a>18、组件的设计技巧</h1><p>在封装一些小组件时，一定要形成习惯，不想暴露给使用者的属性和方法不要写在接口文件中，甚至于某些延续父类的方法不想使用者使用，可以如下处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure>
<p>当然，不用担心组件内部如何获取父类特性，可以通过[super init]来处理。<br>同时，在多人开发中，组件的开放方法名最好加入一些前缀，便于区别，也避免方法重名，最容易导致方法重名的情况就是各种分类里面的方法重复，会带来意想不到的错误。</p>
<h1 id="19、缓存机制的设计"><a href="#19、缓存机制的设计" class="headerlink" title="19、缓存机制的设计"></a>19、缓存机制的设计</h1><p>不管是任何技术栈的缓存机制设计，都需要一套缓存淘汰算法，使用最广泛的淘汰算法就是 LRU，即是最近最少使用淘汰算法，开发者需要严格的控制磁盘缓存和内存缓存的空间占用。</p>
<p>在 iOS 开发中，可以使用 YYCache 来处理缓存机制，该框架的源码剖析可见笔者博客：YYCache 源码剖析：一览亮点</p>
<p>还有一点需要提出的是磁盘缓存的位置问题。iOS 设备沙盒中有 Documents、Caches、Preferences、tmp 等文件夹，其中 Documents 和 Preferences 会被 iCloud 同步。</p>
<p>Documents 适合存储比较重要的数据；Caches 适合存储大量且不那么重要的数据，比如图片缓存、网络数据缓存啥的；tmp 存储临时文件，重启手机或者内存告急时会被清理；Preferences 是偏好设置，适合存储比较个性化的数据。</p>
<p>值得注意的是，NSUserDefaults是存储在 Preferences 下的文件，发现有很多开发者为了偷懒频繁的使用NSUserDefaults做任意数据的磁盘缓存，这是一个很不合理的做法，用处不大且大量的数据一般缓存在 Caches 中，就算是从技术角度考虑，NSUserDefaults是以 .plist 形式存储的，不适合大数据存储。</p>
<h1 id="20、合理选择数字类型"><a href="#20、合理选择数字类型" class="headerlink" title="20、合理选择数字类型"></a>20、合理选择数字类型</h1><p>软件工程师应该清楚自己编写的代码是运行在 32 位还是 64 位的系统上，并且了解编程语言对于各种数字类型的定义。</p>
<p>在 iOS 领域，CGFloat在 32 位系统中为 float 单精度，64 位系统中为 double 双精度，当将一个NSNumber转换为数字类型时，为了兼容，需要如下写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *number = ...;</span><br><span class="line">CGFloat result = 0;</span><br><span class="line">#if CGFLOAT_IS_DOUBLE</span><br><span class="line">      result  = number.doubleValue;</span><br><span class="line">#else</span><br><span class="line">      result  = number.floatValue;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>在使用不同数字类型时，需要考虑数字类型的表示范围，比如能用short处理的就不要用long int。</p>
<p>同时，数字类型的精度问题往往困扰着新手开发者。不管是单精度 (float) 还是双精度 (double) 它们都是基于浮点计数实现的，包含了符号域、指数域、尾数域，而在计算机的理解里数字就是二进制，所以浮点数基于二进制的科学计数法形如：1.0101 * 2^n ，这可不像十进制那样方便的表示十进制小数，比如在十进制中使用 10^-1 轻松的表示十进制的 0.1 ，而二进制方式却无法实现（试想 2 的几次方等于十进制的 0.1 ？），所以浮点数只能用最大限度的近似值表示这些无法精确表示的小数。</p>
<p>比如写一句代码 float f = 0.1;打一个断点可以看到它实际的值是：f = 0.100000001。</p>
<p>和浮点计数相对的是定点计数，定点计数比较直观，比如：10.0101 ，它的弊端就是对于有效位数过多的数字，需要大量的空间来存储。所以为了存储空间的高效利用，使用最广泛的仍然是“不够精确”的基于浮点计数的单精度和双精度类型。</p>
<p>然而，在一些特定场景下，定点计数仍然能发挥它的优势，比如金钱计算。</p>
<p>对于金钱计算的处理，往往都是要求绝对准确的，所以在很多语言中都有基于定点计数的数据类型，比如 Java 中的 BigDecimal、Objective-C 中的 NSDecimalNumber，牺牲一些空间和时间来达到精确的计算。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Johnny" />
            
              <p class="site-author-name" itemprop="name">Johnny</p>
              <p class="site-description motion-element" itemprop="description">仰天大笑出门去 我辈岂是蓬蒿人</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"> ifunnyy | Johnny</span>

  
</div>


  <div class="powered-by"> _(:з」∠)_</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">博客 &mdash;  v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
